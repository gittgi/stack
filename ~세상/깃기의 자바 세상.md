# 깃기의 자바 세상



## 자료형



### 숫자

#### 정수

int :  -2147483648 ~ 2147483647 를 표현하는 자료형

long :   -9223372036854775808 ~ 9223372036854775807를 표현하는 자료형

```java
int age = 10;
long countOfStar = 8764827384923849L; // int의 최댓값보다 큰 경우를 long 변수에 대입하는 경우 끝에 'L' 붙이기
```

>byte, short등도 있지만, 잘 사용하지 않음



#### 실수

Float : -3.4 * 10^38 ~ 3.4 * 10^38 를 표현하는 자료형

double : -1.7 * 10^308 ~ 1.7 * 10^308 를 표현하는 자료형

```java
float pi = 3.14F;
double morePi = 3.14159265358979323846;
// 디폴트가 double이기 때문에 float 변수에 값을 대입할 때에는 끝에 'F'를 붙이기

double d1 = 123.4;
double d2 = 1.234e2;
// e2 10의 제곱을 의미
```



#### 8진수와 16진수

```java
int octal = 023;    // 십진수: 19, 0(숫자 0)으로 시작하면 8진수
int hex = 0xC;     // 십진수: 12, 0x(숫자 0 + 문자 x)로 시작하면 16진수
```



#### 증감연산

```java
int i = 0;
int j = 10;
i++;
j--;

System.out.println(i);  // 1 출력
System.out.println(j);  // 9 출력

```

참고로 ++i 와 i++의 값 증가 시점이 다르다

```java
int i = 0;
System.out.println(++i);  // 1 출력, ++가 앞에 붙을 경우, 값이 참조 되기 전에 증가하고, 반대의 경우 값이 참조된 이후에 증가
System.out.println(i);  // 1 출력

```



### 불

불 자료형에는 불 연산의 결과값이 대입될 수 있다.

```java
2 > 1             // 참
1 == 2            // 거짓
3 % 2 == 1        // 참 (3을 2로 나눈 나머지는 1이므로 참이다.)
"3".equals("2")   // 거짓 
```



### 문자

한 개의 문자 값에 대한 자료형은 char

```java
char a1 = 'a'; // 문자값을 '' 로 감싸주기
```

char 는 잘 사용되지 않는 자료형

char는 문자값을 표현하는 방식이 다양

```java
char a1 = 'a';  // 문자로 표현
char a2 = 97;  // 아스키코드로 표현
char a3 = '\u0061';  // 유니코드로 표현

System.out.println(a1);  // a 출력
System.out.println(a2);  // a 출력
System.out.println(a3);  // a 출력

```



### 문자열

문자들로 구성된 문자를 문자열, String으로 나타냄

```java
// 리터럴 표기 (가독성 + 컴파일 시 최적화)
String a = "Happy Java";
String b = "a";
String c = "123";

// 객체 생성방식
String a = new String("Happy Java");
String b = new String("a");
String c = new String("123");
```



#### 원시(primitive)자료형

int, long, double, boolean, char 자료형은 원시 자료형에 해당,

이런 자료형들은 new 키워드로 생성 불가, 대신 리터럴로 값을 세팅

String은 리터럴로도 사용 가능한 특별 케이스



##### 원시 자료형의 Wrapper 클래스

| 원시자료형 | Wrapper 클래스 |
| :--------: | :------------: |
|    int     |    Integer     |
|    long    |      Long      |
|   double   |     Double     |
|   float    |     Float      |
|  boolean   |    Boolean     |
|    char    |      Char      |

ArrayList, HashMap, HashSet 등은 데이터를 생성할 때, 원시 자료형 대신 그에 대응하는 Wrapper 클래스를 사용해야 함

Wrapper클래스를 사용하면 값 대신 객체를 주고받고, 멀티스레딩 환경에서 동기화를 지원하기에도 유리



#### 문자열 내장 메서드

1. equals : 두개의 문자열이 동일한지 비교한 결과값을 리턴

   (참고) 문자열을 비교할 때, `==`의 경우에는 두 개의 자료형이 동일한 객체인지를 판별하는 연산자이기 때문에, 값이 같아보여도 다른 객체인 경우 false가 뜰 수 있다. 따라서 값을 비교할 때는 equals 사용

   ```java
   String a = "hello";
   String b = "java";
   String c = "hello";
   System.out.println(a.equals(b)); // false 출력
   System.out.println(a.equals(c)); // true 출력
   ```

2. indexOf : 문자열에서 특정 문자열이 시작되는 위치(인덱스) 리턴

   ```java
   String a = "Hello Java";
   System.out.println(a.indexOf("Java"));  // 6 출력
   ```

3. Contains : 문자열에서 특정 문자열이 포함되어 있는지의 여부를 리턴 

   ```java
   String a = "Hello Java";
   System.out.println(a.contains("Java"));  // true 출력
   
   ```

4. charAt : 문자열에서 특정 위치의 문자(char)를 리턴

   ```java
   String a = "Hello Java";
   System.out.println(a.charAt(6));  // "J" 출력
   
   ```

5. replaceAll : 문자열 중 특정 문자열을 다른 문자열로 바꿈

   ```java
   String a = "Hello Java";
   System.out.println(a.replaceAll("Java", "World"));  // Hello World 출력
   
   ```

6. substring : 문자열 중 특정 부분을 뽑아냄

   ```java
   String a = "Hello Java";
   System.out.println(a.substring(0, 4));  // Hell 출력
   
   ```

7. toUpperCase / toLowerCase : 문자열을 모두 대문자 / 소문자로 바꿈

   ```java
   String a = "Hello Java";
   System.out.println(a.toUpperCase());  // HELLO JAVA 출력
   
   ```

8. split : 문자열을 특정 구분자로 나누어 문자열 배열로 리턴

   ```java
   String a = "a:b:c:d";
   String[] result = a.split(":");  // result는 {"a", "b", "c", "d"}
   
   ```



#### 문자열 포매팅

1. 숫자 바로 대입

   ```java
   System.out.println(String.format("I eat %d apples.", 3));  // "I eat 3 apples." 출력
   
   ```

2. 문자열 바로 대입

   ```java
   System.out.println(String.format("I eat %s apples.", "five"));  // "I eat five apples." 출력
   
   ```

3. 숫자 값을 나타내는 변수로 대입

   ```java
   int number = 3;
   System.out.println(String.format("I eat %d apples.", number));  // "I eat 3 apples." 출력
   
   ```

4. 2개 이상의 값 넣기

   ```java
   int number = 10;
   String day = "three";
   System.out.println(String.format("I ate %d apples. so I was sick for %s days.", number, day)); // 앞에서부터 순서대로 파라미터 전달
   
   ```

#### 문자열 포맷 코드

| 코드 |           설명            |
| :--: | :-----------------------: |
|  %s  |      문자열(String)       |
|  %c  |    문자 1개(character)    |
|  %d  |       정수(Integer)       |
|  %f  | 부동소수(floating-point)  |
|  %o  |           8진수           |
|  %x  |          16진수           |
|  %%  | Literal % (문자 `%` 자체) |

> %s의 경우에는 전달되는 파라미터를 자동으로 문자열로 바꾸어서 사용
>
> 포매팅 연산자가 출력하려는 문자열에 존재하는 경우에는 '%'를 문자열로 사용 못하기 때문에, ''%%''로 표기해야 %가 제대로 출력됨

#### 포맷 코드와 숫자 함께 사용하기

1. 정렬과 공백

   ```java
   // %10s : 전체 길이가 10개인 문자열 공간에서 대입되는 값을 오른쪽으로 정렬하고 그 앞의 나머지는 공백으로 남기기
   System.out.println(String.format("%10s", "hi"));  // "        hi" 출력
   
   // %-10s : 전체 길이가 10개인 문자열 공간에서 대입되는 값으로 왼쪽 정렬하고 그 뒤의 나머지는 공백으로 남기기
   System.out.println(String.format("%-10sjane.", "hi"));  // "hi        jane." 출력
   ```

   

2. 소수점 표현하기

   ```java
   // .4 는 소수점 뒤의 4자리까지 출력하겠다는 뜻
   System.out.println(String.format("%.4f", 3.42134234));  // 3.4213 출력
   
   // 정렬과 공백도 같이 사용 가능
   System.out.println(String.format("%10.4f", 3.42134234));  // '    3.4213' 출력
   
   ```
   
   

#### System.out.printf

`String.format` 메서드는 포매팅된 문자열을 리턴

따라서 포매팅된 문자열을 출력하려면 `System.out.println` 메서드를 함께 사용

```java
System.out.println(String.format("I eat %d apples.", 3));

```

하지만 `System.out.printf` 메서드를 사용하면 바로 가능

```java
System.out.printf("I eat %d apples.", 3);  // "I eat 3 apples." 출력

```

`String.format`은 문자열을 리턴하는 메서드, `System.out.printf`는 문자열을 출력하는 메서드




### StringBuffer

StringBuffer는 문자열을 추가하거나 변경할 때 주로 사용하는 자료형



1. append : 객체에 문자열 추가

   ```java
   StringBuffer sb = new StringBuffer();  // StringBuffer 객체 sb 생성
   sb.append("hello");
   sb.append(" ");
   sb.append("jump to java");
   String result = sb.toString(); // 이후 .toString()로 String 자료형으로 변환
   System.out.println(result);  // "hello jump to java" 출력
   
   ```

   ```java
   String result = "";
   result += "hello";
   result += " ";
   result += "jump to java";
   System.out.println(result);  // "hello jump to java" 출력
   
   ```

   아래의 예제는 String을 사용한 방법

   String을 사용해서 추가할 경우 매번 새로운 String 객체가 생성되기 때문에 코스트가 있다

   반면에 StringBuffer의 경우에는 비교적 무거운 자료형이지만, 값이 변경되는 mutable 자료형이라 수정이 가능하다

   따라서 자주 변경되는 문자열의 경우에는 StringBuffer로, 자주 변경되지 않는 자료형의 경우에는 String을 사용하는 것을 권장

   (참고) StringBuilder의 경우에는 StringBuffer와 사용법이 동일하고, 성능은 좀 더 우수하다. 다만, StringBuffer가 멀티 스레드 환경에서 더 안전하기 때문에, 동기화를 고려해야 하는지의 여부에 따라 선택하는 것을 추천

   

2. insert : 특정 위치에 원하는 문자열을 삽입

   ```java
   StringBuffer sb = new StringBuffer();
   sb.append("jump to java");
   sb.insert(0, "hello "); // 0번째에 문자열 'hello' 삽입
   System.out.println(sb.toString());
   
   ```

3. substring : String의 substring과 동일하게 동작

   ```java
   StringBuffer sb = new StringBuffer();
   sb.append("Hello jump to java");
   System.out.println(sb.substring(0, 4));
   
   ```



### 배열 (Array)

배열은 자료형 타입 옆에 `[]` 기호를 사용해서 표현

```java
int[] odds = {1, 3, 5, 7, 9};
String[] weeks = {"월", "화", "수", "목", "금", "토", "일"};

```



#### 배열의 특징

1. 배열의 길이는 고정

   ```java
   String[] weeks = new String[7]; // 초기값 없이 생성하는 경우 길이 지정 필수
   weeks[0] = "월";
   weeks[1] = "화";
   weeks[2] = "수";
   weeks[3] = "목";
   weeks[4] = "금";
   weeks[5] = "토";
   weeks[6] = "일";
   
   ```

   배열의 길이를 먼저 설정하고 나중에 대입하는 방식

   이처럼 초기값이 없는 경우에는 반드시 `[7]` 처럼 배열의 길이를 지정해줘야 함

2. 인덱싱

   배열 뒤에 [숫자] 로 인덱싱

   ```java
   String[] weeks = {"월", "화", "수", "목", "금", "토", "일"};
   System.out.println(weeks[3]); // "목"
   
   ```

3. 배열의 길이는 .length로 확인

   ```java
   String[] weeks = {"월", "화", "수", "목", "금", "토", "일"};
   for (int i = 0; i < weeks.length; i++) {
       System.out.println(weeks[i]);
   }
   
   ```

4. 자주 발생하는 배열의 오류

   `ArrayIndexOutOfBoundsException` 배열의 길이를 넘어가는 요소를 구할 경우 발생



### 리스트(List)

리스트는 배열과 비슷하지만 더 편리한 기능이 많음

가장 큰 차이점은 리스트의 크기는 동적으로 변한다는 점

리스트 자료형에는 ArrayList, Vector, LinkedList등 리스트 인터페이스를 구현한 자료형들이 있다

#### ArrayList

1. add : 추가

   ```java
   import java.util.ArrayList; // import 필요
   
   public class Sample {
       public static void main(String[] args) {
           ArrayList<String> pitches = new ArrayList<>(); // 제네릭스: 객체를 포함하는 자료형도 명시
           pitches.add("138"); // 138을 ArrayList에 추가
           pitches.add(0, "129"); // 129를 첫번째 위치에 삽입
           pitches.add(1, "142"); // 133을 두번째 위치에 삽입
       }
   }
   
   ```

   



2. get : 추출

   ```java
   import java.util.ArrayList;
   
   public class Sample {
       public static void main(String[] args) {
           ArrayList pitches = new ArrayList();
           pitches.add("138");
           pitches.add("129");
           pitches.add("142");
           System.out.println(pitches.get(1)); // 1번 인덱스의 값 추출
       }
   }
   
   ```



3. size : 요소의 갯수

   ```java
   System.out.println(pitches.size()); // 3
   
   ```

   

4. contains : 리스트 안에 해당 항목이 있는지를 판별

   ```java
   System.out.println(pitches.contains("142")); // true
   
   ```



5. remove : 항목이나 인덱스의 요소를 삭제

   1. remove(객체) : 리스트에서 객체에 해당되는 항목을 삭제하고, 삭제한 결과(true, false)를 리턴

      ```java
      System.out.println(pitches.remove("129")); // true
      
      ```

   2. remove(인덱스) : 해당 인덱스의 항목을 삭제하고 삭제된 항목을 리턴

      ```java
      System.out.println(pitches.remove(0)); // 138
      
      ```



#### (참고) 제네릭스

제네릭스를 사용해서 리스트안의 요소들의 자료형을 명시

```java
ArrayList<String> pitches = new ArrayList<>();  // 선호되는 방식

```

참고로 뒷부분의 자료형은 앞부분에 명시했기 때문에 적지 않는 것이 선호된다.



만약 제네릭스를 사용하지 않는 경우, 기본적으로 리스트에 들어가는 자료형은 Object로 인식

값을 넣을 때는 문제가 되지 않지만, 꺼낼 때는 타입캐스팅으로 일일이 바꿔야 하는 불편함

추가로 만약 생각과는 다른 자료형이 들어가고, 그것을 가령 String으로 자료형으로 캐스팅하려고 하면 오류 가능성

```java
ArrayList pitches = new ArrayList();
pitches.add("138");
pitches.add("129");

String one = (String) pitches.get(0);
String two = (String) pitches.get(1);

```

```java
ArrayList<String> pitches = new ArrayList<>();
pitches.add("138");
pitches.add("129");

String one = pitches.get(0);  // 형 변환이 필요없다.
String two = pitches.get(1);  // 형 변환이 필요없다.

```



#### ArrayList 만들기

1. add 메서드로 요소 추가하기

   ```java
   import java.util.ArrayList;
   
   public class Sample {
       public static void main(String[] args) {
           ArrayList<String> pitches = new ArrayList<>();  // 제네릭스를 사용한 표현
           pitches.add("138");
           pitches.add("129");
           pitches.add("142");
           System.out.println(pitches);  // [138, 129, 142] 출력
       }
   }
   
   ```

   

2. 이미 있는 Array를 ArrayList로 만들기 (java.util.Arrays 필요)

   ```java
   import java.util.ArrayList;
   import java.util.Arrays;
   
   public class Sample {
       public static void main(String[] args) {
           String[] data = {"138", "129", "142"};  // 이미 투구수 데이터 배열이 있다.
           ArrayList<String> pitches = new ArrayList<>(Arrays.asList(data));// Arrays.asList()의 인자로 배열 넣어주기
           System.out.println(pitches);  // [138, 129, 142] 출력
       }
   }
   
   ```

   또는 배열대신 원소를 여러개 넣어주는 형태도 가능

   ```java
   import java.util.ArrayList;
   import java.util.Arrays;
   
   public class Sample {
       public static void main(String[] args) {
           ArrayList<String> pitches = new ArrayList<>(Arrays.asList("138", "129", "142")); // 배열대신 여러 요소 추가
           System.out.println(pitches);
       }
   }
   
   ```



#### String.join

배열 안에 있는 문자열들을 특정 구분자로 합치는 메서드

`String.join("구분자", 리스트객체)`

```java
import java.util.ArrayList;
import java.util.Arrays;

public class Sample {
    public static void main(String[] args) {
        ArrayList<String> pitches = new ArrayList<>(Arrays.asList("138", "129", "142"));
        String result = String.join(",", pitches);
        System.out.println(result);  // 138,129,142 출력
    }
}

```

다음과 같은 문자열 배열에도 사용 가능

```java
public class Sample {
    public static void main(String[] args) {
        String[] pitches = new String[]{"138", "129", "142"};
        String result = String.join(",", pitches);
        System.out.println(result);  // 138,129,142 출력
    }
}

```



#### 리스트 정렬

Java.util.Comaprator에 있는 sort 메서드 활용

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

public class Sample {
    public static void main(String[] args) {
        ArrayList<String> pitches = new ArrayList<>(Arrays.asList("138", "129", "142"));
        pitches.sort(Comparator.naturalOrder());  // 오름차순으로 정렬
        System.out.println(pitches);  // [129, 138, 142] 출력
    }
}

```

sort의 인자로 정렬방향 설정

- 오름차순(순방향) 정렬 - `Comparator.naturalOrder()`
- 내림차순(역방향) 정렬 - `Comparator.reverseOrder()`





### 맵 (Map)

key와 value로 구성된 자료형

배열과 다르게 순차적이지 않고, key값을 통해 value 값을 찾는 것이 특징

자바에는 대표적으로  HashMap, LinkedHashMap, TreeMap 등이 있다



#### HashMap

HashMap 역시 제네릭스를 이용, Key와 Value 모두 String 타입이며, String 타입 이외의 자료형은 쓸 수 없다.

##### put

key 와 value를 추가하는 메서드

```java
import java.util.HashMap;

public class Sample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put("people", "사람");
        map.put("baseball", "야구");
    }
}

```

##### get

key 값으로 value값을 찾는 메서드

```java
System.out.println(map.get("people"));  // "사람" 출력

```

##### getOrDefault

get 메서드의 경우 값이 없을 경우 null을 리턴

getOrDefault의 경우 없을 경우 지정한 디폴트 값을 리턴

```java
System.out.println(map.getOrDefault("java", "자바"));  // "자바" 출력

```

##### constainsKey

해당 키가 있는지 유무(t/f)를 나타내는 메서드

```java
System.out.println(map.containsKey("people"));  // true 출력

```

##### remove

해당 키 값에 해당하는 항목을 삭제한 후 그 value를 리턴

```java
System.out.println(map.remove("people"));  // "사람" 출력

```

##### size

맵의 개수를 리턴

```java
System.out.println(map.size()); // 1


```

##### keySet

맵의 모든 키를 모아서 리턴 (Set자료형으로 리턴)

```java
import java.util.HashMap;

public class Sample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put("people", "사람");
        map.put("baseball", "야구");
        System.out.println(map.keySet());  // [baseball, people] 출력
    }
}

```

(참고) 셋 자료형은 리스트 자료형으로 바꿀 수 있다

```java
List<String> keyList = new ArrayList<>(map.keySet());

```

##### (참고) LinkedHashMap과 TreeMap

LinkedHashMap은 입력된 순서대로 데이터를 저장

TreeMap은 입력된 key의 오름차순 순서로 데이터를 저장하는 특성





### 집합 (Set)

집합은 중복을 허용하지 않고, 순서가 없는 자료형

따라서 집합은 중복을 제거할 때 사용하거나, 교집합, 합집합, 차집합과 같은 집합연산을 수행할 때 주로 사용



#### 집합 만들기

```java
import java.util.Arrays;
import java.util.HashSet;

public class Sample {
    public static void main(String[] args) {
        HashSet<Integer> s1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        HashSet<Integer> s2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8, 9));
    }
}

```

(참고) 제네릭스로 int를 사용하고 싶은 경우, int의 Wrapper 클래스인 Integer를 대신 사용



#### 교집합

```java
import java.util.Arrays;
import java.util.HashSet;

public class Sample {
    public static void main(String[] args) {
        HashSet<Integer> s1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        HashSet<Integer> s2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8, 9));

        HashSet<Integer> intersection = new HashSet<>(s1);  // s1으로 intersection 생성
        intersection.retainAll(s2);  // 교집합 수행
        System.out.println(intersection);  // [4, 5, 6] 출력
    }
}

```

retainAll메서드로 교집합 가능

기존의 s1 집합이 변하지 않도록 intersection 이라는 새 집합을 생성 후 수행한 모습



#### 합집합

```java
import java.util.Arrays;
import java.util.HashSet;

public class Sample {
    public static void main(String[] args) {
        HashSet<Integer> s1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        HashSet<Integer> s2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8, 9));

        HashSet<Integer> union = new HashSet<>(s1);  // s1으로 union 생성
        union.addAll(s2); // 합집합 수행
        System.out.println(union);  // [1, 2, 3, 4, 5, 6, 7, 8, 9] 출력
    }
}

```

addAll메서드로 수행



#### 차집합

```java
import java.util.Arrays;
import java.util.HashSet;

public class Sample {
    public static void main(String[] args) {
        HashSet<Integer> s1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        HashSet<Integer> s2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8, 9));

        HashSet<Integer> substract = new HashSet<>(s1);  // s1으로 substract 생성
        substract.removeAll(s2); // 차집합 수행
        System.out.println(substract);  // [1, 2, 3] 출력
    }
}

```

removeAll 메서드로 수행



#### 집합 자료형 관련 메서드

1. add : 값 추가

   ```java
   import java.util.HashSet;
   
   public class Sample {
       public static void main(String[] args) {
           HashSet<String> set = new HashSet<>();
           set.add("Jump");
           set.add("To");
           set.add("Java");
           System.out.println(set);  // [Java, To, Jump] 출력
       }
   }
   
   ```

   

2. addAll : 여러개 한꺼번에 추가

   ```java
   import java.util.Arrays;
   import java.util.HashSet;
   
   public class Sample {
       public static void main(String[] args) {
           HashSet<String> set = new HashSet<>();
           set.add("Jump");
           set.addAll(Arrays.asList("To", "Java"));
           System.out.println(set);  // [Java, To, Jump] 출력
       }
   }
   
   ```

   

3. remove : 특정값 제거

   ```java
   import java.util.Arrays;
   import java.util.HashSet;
   
   public class Sample {
       public static void main(String[] args) {
           HashSet<String> set = new HashSet<>(Arrays.asList("Jump", "To", "Java"));
           set.remove("To");
           System.out.println(set);  // [Java, Jump] 출력
       }
   }
   
   ```

   

##### (참고) TreeSet과 LinkedHashSet

- TreeSet : 오름차순으로 값을 정렬하여 저장
- LinkedHashSet : 입력한 순서대로 값을 정렬하여 저장





### 상수집합 (Enum)

서로 관련있는 여러개의 상수 집합을 정의할 때 사용하는 자료형



#### Enum 만들기

```java
enum CoffeeType {
    AMERICANO,
    ICE_AMERICANO,
    CAFE_LATTE
};

```



#### Enum 사용

직접 출력 가능

```java
public class Sample {
    enum CoffeeType {
        AMERICANO,
        ICE_AMERICANO,
        CAFE_LATTE
    };

    public static void main(String[] args) {
        System.out.println(CoffeeType.AMERICANO);  // AMERICANO 출력
        System.out.println(CoffeeType.ICE_AMERICANO);  // ICE_AMERICANO 출력
        System.out.println(CoffeeType.CAFE_LATTE);  // CAFE_LATTE 출력
    }
}

```



혹은 반복문으로도 사용 가능

```java
public class Sample {
    enum CoffeeType {
        AMERICANO,
        ICE_AMERICANO,
        CAFE_LATTE
    };

    public static void main(String[] args) {
        for(CoffeeType type: CoffeeType.values()) {
            System.out.println(type);  // 순서대로 AMERICANO, ICE_AMERICANO, CAFE_LATTE 출력
        }
    }
}

```

`CoffeeType.values()`는 CoffeType의 배열을 리턴



#### Enum의 필요성

- 매직넘버(1과 같은 숫자 상수값)을 사용할 떄보다 코드가 명확해진다.
- 잘못된 값을 사용함으로 인해 발생할 수 있는 위험성이 사라진다.





### 형변환

String -> Integer

```java
public class Sample {
    public static void main(String[] args) {
        String num = "123";
        int n = Integer.parseInt(num);
        System.out.println(n);  // 123 출력
    }
}

```



Integer -> String

```java
public class Sample {
    public static void main(String[] args) {
        int n = 123;
        String num = "" + n; // 앞에 빈 문자열 더해주기
        System.out.println(num);  // 123 출력
    }
}
```

```java
public class Sample {
    public static void main(String[] args) {
        int n = 123;
        String num1 = String.valueOf(n);
        String num2 = Integer.toString(n);
        System.out.println(num1);  // 123 출력
        System.out.println(num2);  // 123 출력
    }
}
```



String -> double

```java
public class Sample {
    public static void main(String[] args) {
        String num = "123.456";
        double d = Double.parseDouble(num); // Float은 parseFloat
        System.out.println(d);
    }
}

```



double(float) <-> int

```java
public class Sample {
    public static void main(String[] args) {
        int n1 = 123;
        double d1 = n1;  // 정수를 실수로 바꿀때에는 캐스팅이 필요없다.
        System.out.println(d1);  // 123.0 출력

        double d2 = 123.456;
        int n2 = (int) d2; // 실수를 정수로 바꿀때에는 반드시 정수형으로 캐스팅해 주어야 한다.
        System.out.println(n2);  // 소숫점이 생략된 123 출력
    }
}

```

(참고) 실수를 정수로 변환하면 소숫점은 제거됨, 실수 형태의 문자열을 정수로 변경하려고 하면 NumberFormatException이 발생

```
public class Sample {
    public static void main(String[] args) {
        String num = "123.456";
        int n = Integer.parseInt(num);  // 실수 형태의 문자열을 정수로 변환할 경우 NumberFormatException이 발생한다.
    }
}

```

실수 형태의 문자열을 숫자형으로 변경하려면 `Double.parseDouble()` 을 사용하여 실수로 바꾼후에 사용



### final

final은 자료형에 값을 단 한번만 설정할 수 있게 강제하는 키워드

값을 한번 설정하면 그 값을 다시 설정할 수 없음

```java
public class Sample {
    public static void main(String[] args) {
        final int n = 123;  // final 로 설정하면 값을 바꿀수 없다.
        n = 456;  // 컴파일 에러 발생
    }
}

```

리스트의 경우, final로 선언시 재할당은 불가능

```java
import java.util.ArrayList;
import java.util.Arrays;

public class Sample {
    public static void main(String[] args) {
        final ArrayList<String> a = new ArrayList<>(Arrays.asList("a", "b"));
        a = new ArrayList<>(Arrays.asList("c", "d"));  // 컴파일 에러 발생
    }
}

```

따라서 final은 프로그램 수행 도중 그 값이 변경되면 안되는 상황에 사용



#### (참고) Unmodifiable List

리스트의 경우 final로 선언시 리스트에 값을 더하거나 빼는 것이 가능 (재할당이 불가능 한 것)

만약 더하기 빼기도 금지 시키고 싶다면, List.of로 수정이 불가능한 리스트로 만들기

```java
import java.util.List;

public class Sample {
    public static void main(String[] args) {
        final List<String> a = List.of("a", "b"); // Unmodifiable List 생성
        a.add("c");  // UnsupportedOperationException 발생
    }
}

```





## 제어문



### if



#### 기본 구조

```java
boolean money = true;
if (money) {
    System.out.println("택시를 타고 가라");
}else {
    System.out.println("걸어가라");
}

```

Else if 

```java
boolean hasCard = true;
ArrayList<String> pocket = new ArrayList<String>();
pocket.add("paper");
pocket.add("handphone");

if (pocket.contains("money")) {
    System.out.println("택시를 타고 가라");
}else if(hasCard) {
    System.out.println("택시를 타고 가라");
}else {         
    System.out.println("걸어가라");
}

```





#### and(&&), or(||), not(!)

```java
int money = 2000;
boolean hasCard = true;

if (money>=3000 || hasCard) {
    System.out.println("택시를 타고 가라");
} else {
    System.out.println("걸어가라");
}

```



#### contains

```java
ArrayList<String> pocket = new ArrayList<String>();
pocket.add("paper");
pocket.add("handphone");
pocket.add("money");

if (pocket.contains("money")) {
    System.out.println("택시를 타고 가라");
}else {
    System.out.println("걸어가라");
}

```





### switch/case

#### 기본구조

```java
switch(입력변수) {
    case 입력값1: ...
         break;
    case 입력값2: ...
         break;
    ...
    default: ...
         break;
}

```

Break 문이 case마다 달려있는데, 만약 break가 없다면 다음 case문이 실행됨

만약 해당되는 case가 없다면 마지막의 default문이 실행됨

switch 조건문에 들어갈 수 있는 입력 변수의 타입은 byte, short, char, int 만 가능



### while

#### 기본구조

```java
while (조건문) {
    <수행할 문장1>;
    <수행할 문장2>;
    <수행할 문장3>;
    ...
}
```

조건문이 참인 동안 문장들을 반복 수행

```java
int treeHit = 0;
while (treeHit < 10) {
    treeHit++;
    System.out.println("나무를  " + treeHit + "번 찍었습니다.");
    if (treeHit == 10) {
        System.out.println("나무 넘어갑니다.");
    }
}

```

- break를 이용해서 중단
- continue를 이용하면 반복문의 처음으로 돌아감

#### 

### for문

#### 전형적인 for문

```java
for (초기치; 조건문; 증가치) {
    ...
}

```

';' 를 구분자로 초기치, 조건문, 증가치를 이용해 반복

```java
String[] numbers = {"one", "two", "three"};
for(int i=0; i<numbers.length; i++) {
    System.out.println(numbers[i]);
}
```

마찬가지로 break와 continue 사용 가능

이중for문 등으로 응용 가능



### for each

반복 가능한 객체를 순회하면서 가능

```java
for (type var: iterate) {
    body-of-loop
}

```

```java
String[] numbers = {"one", "two", "three"};
for(String number: numbers) {
    System.out.println(number);
}

```

numbers의 요소를 하나씩 순서대로 꺼내서 number라는 변수로 반복문에서 사용





## 객체지향 프로그래밍



### 클래스

#### 기본형태

```java
class Animal {
}

public class Sample {
    public static void main(String[] args) {
    }
}

```

보통 클래스는 특별한 경우가 아니라면 파일 단위로 하나씩만 작성하고, 해당 파일의 이름과 클래스의 이름을 맞춰는 것이 일반적



#### 객체 생성

```java
class Animal {
}

public class Sample {
    public static void main(String[] args) {
        Animal cat = new Animal(); // 객체 생성
    }
}

```

`new`는 객체를 생성할 때 사용하는 키워드, 여기서는 cat 이라는 Animal의 인스턴스가 만들어진다.

(참고) 인스턴스라는 표현은 특정 객체가 어떤 클래스의 객체인지 그 관계를 설명하기 위해 사용되는 표현



#### 객체 변수 (instance variable)

```java
class Animal {
    String name; // 객체 변수
}

public class Sample {
    public static void main(String[] args) {
        Animal cat = new Animal();
    }
}

```

객체 변수는 인스턴스 변수, 멤버 변수, 속성이라고도 불림

클래스에 선언된 변수를 객체 변수라고 부름

객체 변수는 `객체.객체변수`로 접근해서 사용 가능

```java
cat.name // 객체 : cat, 객체변수 : name
```



#### 메서드

클래스 내에 선언된 함수가 메서드

자바에서는 모든 것이 클래스로 되어있기 때문에 모든 함수는 메서드로 부름

```java
class Animal {
    String name;

    public void setName(String name) {
        this.name = name; // thiss는 해당 메서드가 호출된 객체 (이 예시에서는 cat)
    }
}

public class Sample {
    public static void main(String[] args) {
        Animal cat = new Animal();
      	cat.setName("gittgi") // 메서드 호출
        System.out.println(cat.name);
    }
}

```

객체 변수는 다른 객체들끼리 공유되지 않는다

따라서 cat이 아닌 dog에서는 위에서 설정한 이름이 찍히지 않는다





### 메서드 심화

#### 기본구조

```java
public class Sample {
    int sum(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int a = 3;
        int b = 4;

        Sample sample = new Sample();
        int c = sample.sum(a, b);

        System.out.println(c);
    }
}

```



#### 매개변수와 인수

매개변수(parameter) : 메서드에 입력으로 전달된 값을 받는 변수

인수(arguments) : 메서드를 호출할 때 전달하는 입력값

```java
public class Sample {
    int sum(int a, int b) {  // a, b 는 매개변수
        return a+b;
    }

    public static void main(String[] args) {
        Sample sample = new Sample();
        int c = sample.sum(3, 4);  // 3, 4는 인수

        System.out.println(c);
    }
}

```



#### 입출력 유무에 따른 메서드 분류

1. 입력과 출력이 모두 있는 메서드

   ```java
   int sum(int a, int b) {
       return a+b;
   }
   
   ```

   return으로 주어지는 값의 자료형을 메서드 명 앞에 표기해주어야 한다.

   ```java
   Sample sample = new Sample();
   int result = sample.sum(3, 4); // 활용 할 때에도, return값을 저장할 변수에다가 할당
   
   ```

   

2. 입력값이 없는 메서드

   ```java
   public class Sample {
       String say() {
           return "Hi";
       }
   
       public static void main(String[] args) {
           Sample sample = new Sample();
           String a = sample.say();
           System.out.println(a);  // "Hi" 출력
       }
   }
   
   ```

   인수 없이 단순히 호출해서 쓸 수 있다

   

3. 리턴값이 없는 메서드

   ```
   public class Sample {
       void sum(int a, int b) { 
           System.out.println(a+"과 "+b+"의 합은 "+(a+b)+"입니다.");
       } // 리턴값이 없기 때문에, 리턴값 자료형 대신 void 표기
   
       public static void main(String[] args) {
           Sample sample = new Sample();
           sample.sum(3, 4); // 따로 return 값을 받을 변수에 할당하지 않는다
       }
   }
   
   ```

   리턴 값이 없기에 그냥 statement를 수행하는 용도로 사용



4. 입력값도 리턴값도 없는 메서드

   ```java
   public class Sample {
       void say() {
           System.out.println("Hi");
       }
   
       public static void main(String[] args) {
           Sample sample = new Sample();
           sample.say(); // 인수도 없이 그냥 호출
       }
   }
   
   ```



#### (참고) 자바파일에 2개 이상의 클래스 선언하기

하나의 파일에 여러개의 클래스를 선언하는 것은 가능함, 다만 파일명과 같은 이름을 가진 클래스는 public으로 선언하라는 관례가 있음



### Call by Value

메서드에 값(primitive type)을 전달하는 것과 객체(reference type)를 전달하는 것은 다르다

메서드에 객체를 전달할 경우, 메서드에서 객체의 객체변수 값을 변경 가능



```java
class Updater {
    void update(int count) {
        count++;
    }
}

class Counter {
    int count = 0;  // 객체변수
}

public class Sample {
    public static void main(String[] args) {
        Counter myCounter = new Counter();
        System.out.println("before update:"+myCounter.count); // 0
        Updater myUpdater = new Updater();
        myUpdater.update(myCounter.count);
        System.out.println("after update:"+myCounter.count); // 여전히 0
    }
}

```

값을 객체에서 꺼내서 전달하게 되면, 그 값은 객체와 무관하게 됨



```java
class Updater {
    void update(Counter counter) {
        counter.count++; // 받은 객체의 객체변수를 찾아서 올림
    }
}

class Counter {
    int count = 0;  // 객체변수
}

public class Sample {
    public static void main(String[] args) {
        Counter myCounter = new Counter();
        System.out.println("before update:"+myCounter.count); // 0
        Updater myUpdater = new Updater();
        myUpdater.update(myCounter);
        System.out.println("after update:"+myCounter.count); // 이제 1로 올라감
    }
}

```

객체로 전달하면, 메서드에서 그 객체의 속성을 변경가능해짐



### 상속

자식 클래스가 부모 클래스의 기능을 그대로 물려받을 수 있는 상속 기능



#### 기본구조

```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Dog extends Animal {  // Animal 클래스를 상속한다.
}

public class Sample {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.setName("poppy");
        System.out.println(dog.name);
    }
}

```

extends 키워드를 이용해서 부모 클래스를 상속 받으면, 부모 클래스의 객체 변수 및 메서드를 따로 정의 없이 그대로 사용 가능



#### 부모 클래스의 기능 확장

```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    void sleep() {
        System.out.println(this.name+" zzz"); // 부모 클래스에는 없는 자식 클래스만의 메서드
    }
}

public class Sample {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.setName("poppy");
        System.out.println(dog.name);
        dog.sleep();
    }
}

```

부모 클래스의 기능을 모두 상속 받으면서 추가로 자식 클래스만의 메서드나 변수를 설정할 수 있음



#### IS-A 관계

모든 자식 클래스 객체는 부모 클래스 객체의 자료형인 것처럼 사용 가능

```java
Animal dog = new Dog();  // Dog is a Animal
```



그러나 그 반대는 성립하지 않는다

```java
Dog dog = new Animal();  // 컴파일 오류: 부모 클래스로 만든 객체는 자식 클래스의 자료형으로 사용할 수 없다.
```



##### (참고) Object 클래스

자바의 모든 클래스는 Object 클래스를 상속받음

따라서 Object 자료형으로 사용할 수 있음





#### 메서드 오버라이딩 (Method Overriding)

```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    void sleep() {
        System.out.println(this.name + " zzz");
    }
}

class HouseDog extends Dog {
    void sleep() {
        System.out.println(this.name + " zzz in house"); // 같은 메서드이지만 더 추가 됨
    }
}

public class Sample {
    public static void main(String[] args) {
        HouseDog houseDog = new HouseDog();
        houseDog.setName("happy");
        houseDog.sleep();  // happy zzz in house 출력
    }
}

```

이처럼 부모클래스의 메서드를 자식클래스가 동일한 형태로 또 다시 덮었는 행위를 메서드 오버라이딩이라고 부름



#### 메서드 오버로딩 (Method Overloading)

메서드 오버라이딩이 변경이었다면, 메서드 오버로딩의 경우에는 추가

```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    void sleep() {
        System.out.println(this.name + " zzz");
    }
}

class HouseDog extends Dog {
    void sleep() {
        System.out.println(this.name + " zzz in house");
    }

    void sleep(int hour) {
        System.out.println(this.name + " zzz in house for " + hour + " hours");
    } // 같은 이름이지만 들어가는 입력항목이 다르다
}

public class Sample {
    public static void main(String[] args) {
        HouseDog houseDog = new HouseDog();
        houseDog.setName("happy");
        houseDog.sleep();  // happy zzz in house 출력
        houseDog.sleep(3);  // happy zzz in house for 3 hours 출력
    }
}

```

이처럼 입력항목이 다른 경우, 동일한 이름의 메서드를 만들 수 있음 -> 메서드 오버로딩



**(참고) 자바는 다중상속을 지원하지 않는다**





### 생성자

메서드명이 클래스명과 동일하고 리턴 자료형을 정의하지 않는 메서드를 생성자(Constructor)

생성자는

1. 클래스명과 메서드명이 동일해야하고
2. 리턴 타입을 정의하지 않아야 한다 (void도 쓰지 않는다)

```java
(... 생략 ...)

class HouseDog extends Dog {
    HouseDog(String name) {
        this.setName(name);
    } // 생성자

    void sleep() {
        System.out.println(this.name + " zzz in house");
    }

    void sleep(int hour) {
        System.out.println(this.name + " zzz in house for " + hour + " hours");
    }
}

(... 생략 ...)

```

이렇게 만든 생성자는 new 키워드가 사용될 때 (객체가 생성될 때) 호출됨

이때 파라미터를 설정했다면, 해당 인자를 넣어주지 않으면 컴파일 오류 발생 (예시에서는 name)

```java
(... 생략 ...)

public class Sample {
    public static void main(String[] args) {
        HouseDog dog = new HouseDog("happy"); // 객체 생성시에 이제 name을 넣어줘야 함
        System.out.println(dog.name);
    }
}

```



#### 디폴트 생성자

```
class Dog extends Animal {
    Dog() {
    }

    void sleep() {
        System.out.println(this.name + " zzz");
    }
}

```

위와 같이 생성자 내부에 아무 내용이 없는 생성자를 디폴트 생성자라고 부름

생성자를 따로 지정하지 않으면 컴파일러가 위와 같은 디폴트 생성자를 추가

만약 사용자가 작성한 생성자가 구현되어 있다면, 컴파일러는 디폴트 생성자를 추가하지 않는다

따라서 만약 `new HouseDog()`과 같이 아무 인자도 받지 않는 생성자도 같이 쓰고 싶다면 따로 디폴트 생성자를 또 만들어 줘야 함



#### 생성자 오버로딩

메서드 오버로딩 처럼, 하나의 클래스에 입력항목이 다른 생성자를 만들 수 있다

```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    void sleep() {
        System.out.println(this.name + " zzz");
    }
}

class HouseDog extends Dog {
    HouseDog(String name) {
        this.setName(name);
    } // 문자열을 넣은 경우

    HouseDog(int type) {
        if (type == 1) {
            this.setName("yorkshire");
        } else if (type == 2) {
            this.setName("bulldog");
        }
    } // 숫자를 넣은 경우

    void sleep() {
        System.out.println(this.name + " zzz in house");
    }

    void sleep(int hour) {
        System.out.println(this.name + " zzz in house for " + hour + " hours");
    }
}

public class Sample {
    public static void main(String[] args) {
        HouseDog happy = new HouseDog("happy");
        HouseDog yorkshire = new HouseDog(1);
        System.out.println(happy.name);  // happy 출력
        System.out.println(yorkshire.name);  // yorkshire 출력
    }
}

```





### 인터페이스

implements 키워드를 사용해서 클래스 인터페이스를 구현하도록 함

```
(... 생략 ...)

interface Predator {
}

class Tiger extends Animal implements Predator {
}

class Lion extends Animal implements Predator {    
}

(... 생략 ...)

```

이렇게 하면 각각의 클래스 대신 인터페이스를 자료형으로 쓸 수 있음

```java
/*
변경전
class ZooKeeper {
    void feed(Tiger tiger) {
        System.out.println("feed apple");
    }

    void feed(Lion lion) {
        System.out.println("feed banana");
    }
}
호랑이 객체와 사자 객체를 따로 넣어줘야함
*/

// 변경후
class ZooKeeper {
    void feed(Predator predator) {
        System.out.println("feed apple");
    }
}
// 포식자 인터페이스 객체로 통일
```

이렇게 되면 사육사 객체는 매번 새로운 동물마다 각 클래스를 받는 함수를 따로 메서드 오버로딩 할 필요 없이 프레데터 인터페이스 객체를 받는 하나의 메서드만 있으면 됨 (이후 다른 클래스들이 인터페이스를 구현하도록 하면 됨) 



#### 인터페이스의 메서드

위와 같은 경우, 모든 predetor가 같은 함수를 사용하게 되는데

이를 방지하기 위해 인터페이스안에 메서드를 정의할 수 있다

```java
interface Predator {
    String getFood();
}

(... 생략 ...)

```

이때 인터페이스 내에 정의한 메서드에는 몸통만 정의됨

인터페이스는 규칙이기 때문에, 이 규칙(인터페이스)을 따르는 클래스들은 해당 메서드를 반드시 가져야 한다는 제약을 가지게 됨

따라서 각 동물 클래스들은 각자 그 메서드를 구현해야할 의무가 있음

```java
(... 생략 ...)

class Tiger extends Animal implements Predator {
    public String getFood() {
        return "apple";
    } // 인터페이스의 메서드는 항상 public으로 구현해야 함
}

class Lion extends Animal implements Predator {
    public String getFood() {
        return "banana";
    }
}

(... 생략 ...)

```

이후 해당 인터페이스 객체를 받는 메서드에서 이렇게 활용 가능

```java
(... 생략 ...)

class ZooKeeper {
    void feed(Predator predator) {
        System.out.println("feed "+predator.getFood());
    } // 이렇게 호출하면, 구현체가 각자 정의한 getFood() 메서드가 호출됨
}

(... 생략 ...)

```



#### 인터페이스가 필요한 이유

위의 예시에서 볼 수 있듯이, 매번 동물의 종류를 추가할 때마다 추가와 동시에 사육사 클래스를 수정해야하는 문제를 해결할 수 있다

사육사 클래스는 인터페이스 객체를 받는 것으로 대신하는 것으로, 다른 종류의 클래스가 추가가 되더라도 따로 사육사 클래스를 수정할 필요없는, 독립적인 클래스가 될 수 있다.

물론 Animal 클래스에 getFood메서드를 추가하고 이를 오버라이딩 하는 것으로 대체는 가능하지만, 상속의 경우에는 자식 클래스가 부모클래스의 메서드를 오버라이딩 하지 않고 그대로 사용하는 방법이 가능하다. 반대로 인터페이스의 경우에는 **인터페이스의 메서드를 반드시 구현해야 하는 강제성**이 있다.



#### 디폴트 메서드

인터페이스는 메서드 몸통을 가질 수 없지만, 디폴트 메서드를 사용하면 실제 구현된 형태의 메서드를 가질 수 있다.

```java
interface Predator {
    String getFood();

    default void printFood() {
        System.out.printf("my food is %s\n", getFood());
    } // 디폴트 메서드
}

```

이렇게 디폴트 메서드를 정의하면 이 인터페이스의 구현체에서는 따로 해당 메서드를 구현하지 않아도 사용할 수 있다

동시에 오버라이딩 해서 따로 구현하는 것도 가능하다



#### 스태틱 메서드

인터페이스에 스태틱메서드를 선언하면 `인터페이스명.스테틱메서드명` 처럼, 일반 클래스의 스태틱 메서드를 사용하는 것과 동일하게 사용할 수 있다.

```java
interface Predator {
    String getFood();

    default void printFood() {
        System.out.printf("my food is %s\n", getFood());
    }

    int LEG_COUNT = 4;  // 인터페이스 상수, public static final이 자동 적용됨, 다른 형태의 상수 정의 X

    static int speed() {
        return LEG_COUNT * 30;
    } // Predetor.speed(); 로 사용가능
}

```



#### 인터페이스 다중 상속

```java
interface Predator {
    (... 생략 ...)
}

interface Barkable {
    void bark();
}

interface BarkablePredator extends Predator, Barkable {
} // 인터페이스는 다중 상속이 가능하다

(... 생략 ...)

```

인터페이스는 클래스와 다르게 다중 상속을 지원





### 추상클래스

추상클래스는 인터페이스의 역할도 하면서 클래스의 기능도 가지고 있는 돌연변이 클래스

보통 추상클래스를 인터페이스로 대체하는 것이 좋은 디자인이라고 함



```java
abstract class Predator extends Animal { // 추상 클래스
    abstract String getFood(); // 인터페이스 메서드와 동일

    /*default*/ void printFood() {  // default 를 제거한다.
        System.out.printf("my food is %s\n", getFood());
    }

    static int LEG_COUNT = 4;  // 추상 클래스의 상수는 static 선언이 필요하다.
    static int speed() {
        return LEG_COUNT * 30;
    }
}

(... 생략 ...)

```

추상클래스를 만들기 위해서는 class 앞에 abstract 키워드 사용

또한 인터페이스 메서드와 같은 역할을 하는 메서드에도 abstract 키워드 사용, 몸통이 없고 이를 상속받는 클래스에서 해당 abstract 메서드를 구현해야함

디폴트 메서드는 사용할 수 없고, 상수 역시 인터페이스에서는 자동으로 static으로 인식하지만 추상 클래스에서는 따로 선언해줘야 함

추상 클래스는 일반 클래스와 달리 단독으로 객체를 생성할 수 없고 반드시 해당 추상클래스를 상속한 실제 클래스를 통해서만 객체 생성 가능

추상클래스에는 abstract 메서 외에 실제 메서드도 사용 가능, 이 경우 이를 상속받은 객체들도 그 메서드를 사용가능 (인터페이스의 default 메서드와 동일)



#### 인터페이스와 추상 클래스의 차이

자바 8 버전 부터 인터페이스에 default 메서드가 추가되어 추상 클래스와의 차이점이 모호해짐

하지만 추상 클래스는 인터페이스와는 달리 일반 클래스처럼 객체변수, 생성자, private 메서드등을 가질 수 있다





### 콘솔 입출력

