# 깃기의 자바 세상



## 자료형



### 숫자

#### 정수

int :  -2147483648 ~ 2147483647 를 표현하는 자료형

long :   -9223372036854775808 ~ 9223372036854775807를 표현하는 자료형

```java
int age = 10;
long countOfStar = 8764827384923849L; // int의 최댓값보다 큰 경우를 long 변수에 대입하는 경우 끝에 'L' 붙이기
```

>byte, short등도 있지만, 잘 사용하지 않음



#### 실수

Float : -3.4 * 10^38 ~ 3.4 * 10^38 를 표현하는 자료형

double : -1.7 * 10^308 ~ 1.7 * 10^308 를 표현하는 자료형

```java
float pi = 3.14F;
double morePi = 3.14159265358979323846;
// 디폴트가 double이기 때문에 float 변수에 값을 대입할 때에는 끝에 'F'를 붙이기

double d1 = 123.4;
double d2 = 1.234e2;
// e2 10의 제곱을 의미
```



#### 8진수와 16진수

```java
int octal = 023;    // 십진수: 19, 0(숫자 0)으로 시작하면 8진수
int hex = 0xC;     // 십진수: 12, 0x(숫자 0 + 문자 x)로 시작하면 16진수
```



#### 증감연산

```java
int i = 0;
int j = 10;
i++;
j--;

System.out.println(i);  // 1 출력
System.out.println(j);  // 9 출력

```

참고로 ++i 와 i++의 값 증가 시점이 다르다

```java
int i = 0;
System.out.println(++i);  // 1 출력, ++가 앞에 붙을 경우, 값이 참조 되기 전에 증가하고, 반대의 경우 값이 참조된 이후에 증가
System.out.println(i);  // 1 출력

```



### 불

불 자료형에는 불 연산의 결과값이 대입될 수 있다.

```java
2 > 1             // 참
1 == 2            // 거짓
3 % 2 == 1        // 참 (3을 2로 나눈 나머지는 1이므로 참이다.)
"3".equals("2")   // 거짓 
```



### 문자

한 개의 문자 값에 대한 자료형은 char

```java
char a1 = 'a'; // 문자값을 '' 로 감싸주기
```

char 는 잘 사용되지 않는 자료형

char는 문자값을 표현하는 방식이 다양

```java
char a1 = 'a';  // 문자로 표현
char a2 = 97;  // 아스키코드로 표현
char a3 = '\u0061';  // 유니코드로 표현

System.out.println(a1);  // a 출력
System.out.println(a2);  // a 출력
System.out.println(a3);  // a 출력

```



### 문자열

문자들로 구성된 문자를 문자열, String으로 나타냄

```java
// 리터럴 표기 (가독성 + 컴파일 시 최적화)
String a = "Happy Java";
String b = "a";
String c = "123";

// 객체 생성방식
String a = new String("Happy Java");
String b = new String("a");
String c = new String("123");
```



#### 원시(primitive)자료형

int, long, double, boolean, char 자료형은 원시 자료형에 해당,

이런 자료형들은 new 키워드로 생성 불가, 대신 리터럴로 값을 세팅

String은 리터럴로도 사용 가능한 특별 케이스



##### 원시 자료형의 Wrapper 클래스

| 원시자료형 | Wrapper 클래스 |
| :--------: | :------------: |
|    int     |    Integer     |
|    long    |      Long      |
|   double   |     Double     |
|   float    |     Float      |
|  boolean   |    Boolean     |
|    char    |      Char      |

ArrayList, HashMap, HashSet 등은 데이터를 생성할 때, 원시 자료형 대신 그에 대응하는 Wrapper 클래스를 사용해야 함

Wrapper클래스를 사용하면 값 대신 객체를 주고받고, 멀티스레딩 환경에서 동기화를 지원하기에도 유리



#### 문자열 내장 메서드

1. equals : 두개의 문자열이 동일한지 비교한 결과값을 리턴

   (참고) 문자열을 비교할 때, `==`의 경우에는 두 개의 자료형이 동일한 객체인지를 판별하는 연산자이기 때문에, 값이 같아보여도 다른 객체인 경우 false가 뜰 수 있다. 따라서 값을 비교할 때는 equals 사용

   ```java
   String a = "hello";
   String b = "java";
   String c = "hello";
   System.out.println(a.equals(b)); // false 출력
   System.out.println(a.equals(c)); // true 출력
   ```

2. indexOf : 문자열에서 특정 문자열이 시작되는 위치(인덱스) 리턴

   ```java
   String a = "Hello Java";
   System.out.println(a.indexOf("Java"));  // 6 출력
   ```

3. Contains : 문자열에서 특정 문자열이 포함되어 있는지의 여부를 리턴 

   ```java
   String a = "Hello Java";
   System.out.println(a.contains("Java"));  // true 출력
   
   ```

4. charAt : 문자열에서 특정 위치의 문자(char)를 리턴

   ```java
   String a = "Hello Java";
   System.out.println(a.charAt(6));  // "J" 출력
   
   ```

5. replaceAll : 문자열 중 특정 문자열을 다른 문자열로 바꿈

   ```java
   String a = "Hello Java";
   System.out.println(a.replaceAll("Java", "World"));  // Hello World 출력
   
   ```

6. substring : 문자열 중 특정 부분을 뽑아냄

   ```java
   String a = "Hello Java";
   System.out.println(a.substring(0, 4));  // Hell 출력
   
   ```

7. toUpperCase / toLowerCase : 문자열을 모두 대문자 / 소문자로 바꿈

   ```java
   String a = "Hello Java";
   System.out.println(a.toUpperCase());  // HELLO JAVA 출력
   
   ```

8. split : 문자열을 특정 구분자로 나누어 문자열 배열로 리턴

   ```java
   String a = "a:b:c:d";
   String[] result = a.split(":");  // result는 {"a", "b", "c", "d"}
   
   ```



#### 문자열 포매팅

1. 숫자 바로 대입

   ```java
   System.out.println(String.format("I eat %d apples.", 3));  // "I eat 3 apples." 출력
   
   ```

2. 문자열 바로 대입

   ```java
   System.out.println(String.format("I eat %s apples.", "five"));  // "I eat five apples." 출력
   
   ```

3. 숫자 값을 나타내는 변수로 대입

   ```java
   int number = 3;
   System.out.println(String.format("I eat %d apples.", number));  // "I eat 3 apples." 출력
   
   ```

4. 2개 이상의 값 넣기

   ```java
   int number = 10;
   String day = "three";
   System.out.println(String.format("I ate %d apples. so I was sick for %s days.", number, day)); // 앞에서부터 순서대로 파라미터 전달
   
   ```

#### 문자열 포맷 코드

| 코드 |           설명            |
| :--: | :-----------------------: |
|  %s  |      문자열(String)       |
|  %c  |    문자 1개(character)    |
|  %d  |       정수(Integer)       |
|  %f  | 부동소수(floating-point)  |
|  %o  |           8진수           |
|  %x  |          16진수           |
|  %%  | Literal % (문자 `%` 자체) |

> %s의 경우에는 전달되는 파라미터를 자동으로 문자열로 바꾸어서 사용
>
> 포매팅 연산자가 출력하려는 문자열에 존재하는 경우에는 '%'를 문자열로 사용 못하기 때문에, ''%%''로 표기해야 %가 제대로 출력됨

#### 포맷 코드와 숫자 함께 사용하기

1. 정렬과 공백

   ```java
   // %10s : 전체 길이가 10개인 문자열 공간에서 대입되는 값을 오른쪽으로 정렬하고 그 앞의 나머지는 공백으로 남기기
   System.out.println(String.format("%10s", "hi"));  // "        hi" 출력
   
   // %-10s : 전체 길이가 10개인 문자열 공간에서 대입되는 값으로 왼쪽 정렬하고 그 뒤의 나머지는 공백으로 남기기
   System.out.println(String.format("%-10sjane.", "hi"));  // "hi        jane." 출력
   ```

   

2. 소수점 표현하기

   ```java
   // .4 는 소수점 뒤의 4자리까지 출력하겠다는 뜻
   System.out.println(String.format("%.4f", 3.42134234));  // 3.4213 출력
   
   // 정렬과 공백도 같이 사용 가능
   System.out.println(String.format("%10.4f", 3.42134234));  // '    3.4213' 출력
   
   ```
   
   

#### System.out.printf

`String.format` 메서드는 포매팅된 문자열을 리턴

따라서 포매팅된 문자열을 출력하려면 `System.out.println` 메서드를 함께 사용

```java
System.out.println(String.format("I eat %d apples.", 3));

```

하지만 `System.out.printf` 메서드를 사용하면 바로 가능

```java
System.out.printf("I eat %d apples.", 3);  // "I eat 3 apples." 출력

```

`String.format`은 문자열을 리턴하는 메서드, `System.out.printf`는 문자열을 출력하는 메서드




### StringBuffer

StringBuffer는 문자열을 추가하거나 변경할 때 주로 사용하는 자료형



1. append : 객체에 문자열 추가

   ```java
   StringBuffer sb = new StringBuffer();  // StringBuffer 객체 sb 생성
   sb.append("hello");
   sb.append(" ");
   sb.append("jump to java");
   String result = sb.toString(); // 이후 .toString()로 String 자료형으로 변환
   System.out.println(result);  // "hello jump to java" 출력
   
   ```

   ```java
   String result = "";
   result += "hello";
   result += " ";
   result += "jump to java";
   System.out.println(result);  // "hello jump to java" 출력
   
   ```

   아래의 예제는 String을 사용한 방법

   String을 사용해서 추가할 경우 매번 새로운 String 객체가 생성되기 때문에 코스트가 있다

   반면에 StringBuffer의 경우에는 비교적 무거운 자료형이지만, 값이 변경되는 mutable 자료형이라 수정이 가능하다

   따라서 자주 변경되는 문자열의 경우에는 StringBuffer로, 자주 변경되지 않는 자료형의 경우에는 String을 사용하는 것을 권장

   (참고) StringBuilder의 경우에는 StringBuffer와 사용법이 동일하고, 성능은 좀 더 우수하다. 다만, StringBuffer가 멀티 스레드 환경에서 더 안전하기 때문에, 동기화를 고려해야 하는지의 여부에 따라 선택하는 것을 추천

   

2. insert : 특정 위치에 원하는 문자열을 삽입

   ```java
   StringBuffer sb = new StringBuffer();
   sb.append("jump to java");
   sb.insert(0, "hello "); // 0번째에 문자열 'hello' 삽입
   System.out.println(sb.toString());
   
   ```

3. substring : String의 substring과 동일하게 동작

   ```java
   StringBuffer sb = new StringBuffer();
   sb.append("Hello jump to java");
   System.out.println(sb.substring(0, 4));
   
   ```



### 배열 (Array)

배열은 자료형 타입 옆에 `[]` 기호를 사용해서 표현

```java
int[] odds = {1, 3, 5, 7, 9};
String[] weeks = {"월", "화", "수", "목", "금", "토", "일"};

```



#### 배열의 특징

1. 배열의 길이는 고정

   ```java
   String[] weeks = new String[7]; // 초기값 없이 생성하는 경우 길이 지정 필수
   weeks[0] = "월";
   weeks[1] = "화";
   weeks[2] = "수";
   weeks[3] = "목";
   weeks[4] = "금";
   weeks[5] = "토";
   weeks[6] = "일";
   
   ```

   배열의 길이를 먼저 설정하고 나중에 대입하는 방식

   이처럼 초기값이 없는 경우에는 반드시 `[7]` 처럼 배열의 길이를 지정해줘야 함

2. 인덱싱

   배열 뒤에 [숫자] 로 인덱싱

   ```java
   String[] weeks = {"월", "화", "수", "목", "금", "토", "일"};
   System.out.println(weeks[3]); // "목"
   
   ```

3. 배열의 길이는 .length로 확인

   ```java
   String[] weeks = {"월", "화", "수", "목", "금", "토", "일"};
   for (int i = 0; i < weeks.length; i++) {
       System.out.println(weeks[i]);
   }
   
   ```

4. 자주 발생하는 배열의 오류

   `ArrayIndexOutOfBoundsException` 배열의 길이를 넘어가는 요소를 구할 경우 발생



### 리스트(List)

리스트는 배열과 비슷하지만 더 편리한 기능이 많음

가장 큰 차이점은 리스트의 크기는 동적으로 변한다는 점

리스트 자료형에는 ArrayList, Vector, LinkedList등 리스트 인터페이스를 구현한 자료형들이 있다

#### ArrayList

1. add : 추가

   ```java
   import java.util.ArrayList; // import 필요
   
   public class Sample {
       public static void main(String[] args) {
           ArrayList<String> pitches = new ArrayList<>(); // 제네릭스: 객체를 포함하는 자료형도 명시
           pitches.add("138"); // 138을 ArrayList에 추가
           pitches.add(0, "129"); // 129를 첫번째 위치에 삽입
           pitches.add(1, "142"); // 133을 두번째 위치에 삽입
       }
   }
   
   ```

   



2. get : 추출

   ```java
   import java.util.ArrayList;
   
   public class Sample {
       public static void main(String[] args) {
           ArrayList pitches = new ArrayList();
           pitches.add("138");
           pitches.add("129");
           pitches.add("142");
           System.out.println(pitches.get(1)); // 1번 인덱스의 값 추출
       }
   }
   
   ```



3. size : 요소의 갯수

   ```java
   System.out.println(pitches.size()); // 3
   
   ```

   

4. contains : 리스트 안에 해당 항목이 있는지를 판별

   ```java
   System.out.println(pitches.contains("142")); // true
   
   ```



5. remove : 항목이나 인덱스의 요소를 삭제

   1. remove(객체) : 리스트에서 객체에 해당되는 항목을 삭제하고, 삭제한 결과(true, false)를 리턴

      ```java
      System.out.println(pitches.remove("129")); // true
      
      ```

   2. remove(인덱스) : 해당 인덱스의 항목을 삭제하고 삭제된 항목을 리턴

      ```java
      System.out.println(pitches.remove(0)); // 138
      
      ```



#### (참고) 제네릭스

제네릭스를 사용해서 리스트안의 요소들의 자료형을 명시

```java
ArrayList<String> pitches = new ArrayList<>();  // 선호되는 방식

```

참고로 뒷부분의 자료형은 앞부분에 명시했기 때문에 적지 않는 것이 선호된다.



만약 제네릭스를 사용하지 않는 경우, 기본적으로 리스트에 들어가는 자료형은 Object로 인식

값을 넣을 때는 문제가 되지 않지만, 꺼낼 때는 타입캐스팅으로 일일이 바꿔야 하는 불편함

추가로 만약 생각과는 다른 자료형이 들어가고, 그것을 가령 String으로 자료형으로 캐스팅하려고 하면 오류 가능성

```java
ArrayList pitches = new ArrayList();
pitches.add("138");
pitches.add("129");

String one = (String) pitches.get(0);
String two = (String) pitches.get(1);

```

```java
ArrayList<String> pitches = new ArrayList<>();
pitches.add("138");
pitches.add("129");

String one = pitches.get(0);  // 형 변환이 필요없다.
String two = pitches.get(1);  // 형 변환이 필요없다.

```



#### ArrayList 만들기

1. add 메서드로 요소 추가하기

   ```java
   import java.util.ArrayList;
   
   public class Sample {
       public static void main(String[] args) {
           ArrayList<String> pitches = new ArrayList<>();  // 제네릭스를 사용한 표현
           pitches.add("138");
           pitches.add("129");
           pitches.add("142");
           System.out.println(pitches);  // [138, 129, 142] 출력
       }
   }
   
   ```

   

2. 이미 있는 Array를 ArrayList로 만들기 (java.util.Arrays 필요)

   ```java
   import java.util.ArrayList;
   import java.util.Arrays;
   
   public class Sample {
       public static void main(String[] args) {
           String[] data = {"138", "129", "142"};  // 이미 투구수 데이터 배열이 있다.
           ArrayList<String> pitches = new ArrayList<>(Arrays.asList(data));// Arrays.asList()의 인자로 배열 넣어주기
           System.out.println(pitches);  // [138, 129, 142] 출력
       }
   }
   
   ```

   또는 배열대신 원소를 여러개 넣어주는 형태도 가능

   ```java
   import java.util.ArrayList;
   import java.util.Arrays;
   
   public class Sample {
       public static void main(String[] args) {
           ArrayList<String> pitches = new ArrayList<>(Arrays.asList("138", "129", "142")); // 배열대신 여러 요소 추가
           System.out.println(pitches);
       }
   }
   
   ```



#### String.join

배열 안에 있는 문자열들을 특정 구분자로 합치는 메서드

`String.join("구분자", 리스트객체)`

```java
import java.util.ArrayList;
import java.util.Arrays;

public class Sample {
    public static void main(String[] args) {
        ArrayList<String> pitches = new ArrayList<>(Arrays.asList("138", "129", "142"));
        String result = String.join(",", pitches);
        System.out.println(result);  // 138,129,142 출력
    }
}

```

다음과 같은 문자열 배열에도 사용 가능

```java
public class Sample {
    public static void main(String[] args) {
        String[] pitches = new String[]{"138", "129", "142"};
        String result = String.join(",", pitches);
        System.out.println(result);  // 138,129,142 출력
    }
}

```



#### 리스트 정렬

Java.util.Comaprator에 있는 sort 메서드 활용

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

public class Sample {
    public static void main(String[] args) {
        ArrayList<String> pitches = new ArrayList<>(Arrays.asList("138", "129", "142"));
        pitches.sort(Comparator.naturalOrder());  // 오름차순으로 정렬
        System.out.println(pitches);  // [129, 138, 142] 출력
    }
}

```

sort의 인자로 정렬방향 설정

- 오름차순(순방향) 정렬 - `Comparator.naturalOrder()`
- 내림차순(역방향) 정렬 - `Comparator.reverseOrder()`





### 맵 (Map)

key와 value로 구성된 자료형

배열과 다르게 순차적이지 않고, key값을 통해 value 값을 찾는 것이 특징

자바에는 대표적으로  HashMap, LinkedHashMap, TreeMap 등이 있다



#### HashMap

HashMap 역시 제네릭스를 이용, Key와 Value 모두 String 타입이며, String 타입 이외의 자료형은 쓸 수 없다.

##### put

key 와 value를 추가하는 메서드

```java
import java.util.HashMap;

public class Sample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put("people", "사람");
        map.put("baseball", "야구");
    }
}

```

##### get

key 값으로 value값을 찾는 메서드

```java
System.out.println(map.get("people"));  // "사람" 출력

```

##### getOrDefault

get 메서드의 경우 값이 없을 경우 null을 리턴

getOrDefault의 경우 없을 경우 지정한 디폴트 값을 리턴

```java
System.out.println(map.getOrDefault("java", "자바"));  // "자바" 출력

```

##### constainsKey

해당 키가 있는지 유무(t/f)를 나타내는 메서드

```java
System.out.println(map.containsKey("people"));  // true 출력

```

##### remove

해당 키 값에 해당하는 항목을 삭제한 후 그 value를 리턴

```java
System.out.println(map.remove("people"));  // "사람" 출력

```

##### size

맵의 개수를 리턴

```java
System.out.println(map.size()); // 1


```

##### keySet

맵의 모든 키를 모아서 리턴 (Set자료형으로 리턴)

```java
import java.util.HashMap;

public class Sample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        map.put("people", "사람");
        map.put("baseball", "야구");
        System.out.println(map.keySet());  // [baseball, people] 출력
    }
}

```

(참고) 셋 자료형은 리스트 자료형으로 바꿀 수 있다

```java
List<String> keyList = new ArrayList<>(map.keySet());

```

##### (참고) LinkedHashMap과 TreeMap

LinkedHashMap은 입력된 순서대로 데이터를 저장

TreeMap은 입력된 key의 오름차순 순서로 데이터를 저장하는 특성





### 집합 (Set)

집합은 중복을 허용하지 않고, 순서가 없는 자료형

따라서 집합은 중복을 제거할 때 사용하거나, 교집합, 합집합, 차집합과 같은 집합연산을 수행할 때 주로 사용



#### 집합 만들기

```java
import java.util.Arrays;
import java.util.HashSet;

public class Sample {
    public static void main(String[] args) {
        HashSet<Integer> s1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        HashSet<Integer> s2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8, 9));
    }
}

```

(참고) 제네릭스로 int를 사용하고 싶은 경우, int의 Wrapper 클래스인 Integer를 대신 사용



#### 교집합

```java
import java.util.Arrays;
import java.util.HashSet;

public class Sample {
    public static void main(String[] args) {
        HashSet<Integer> s1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        HashSet<Integer> s2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8, 9));

        HashSet<Integer> intersection = new HashSet<>(s1);  // s1으로 intersection 생성
        intersection.retainAll(s2);  // 교집합 수행
        System.out.println(intersection);  // [4, 5, 6] 출력
    }
}

```

retainAll메서드로 교집합 가능

기존의 s1 집합이 변하지 않도록 intersection 이라는 새 집합을 생성 후 수행한 모습



#### 합집합

```java
import java.util.Arrays;
import java.util.HashSet;

public class Sample {
    public static void main(String[] args) {
        HashSet<Integer> s1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        HashSet<Integer> s2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8, 9));

        HashSet<Integer> union = new HashSet<>(s1);  // s1으로 union 생성
        union.addAll(s2); // 합집합 수행
        System.out.println(union);  // [1, 2, 3, 4, 5, 6, 7, 8, 9] 출력
    }
}

```

addAll메서드로 수행



#### 차집합

```java
import java.util.Arrays;
import java.util.HashSet;

public class Sample {
    public static void main(String[] args) {
        HashSet<Integer> s1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        HashSet<Integer> s2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8, 9));

        HashSet<Integer> substract = new HashSet<>(s1);  // s1으로 substract 생성
        substract.removeAll(s2); // 차집합 수행
        System.out.println(substract);  // [1, 2, 3] 출력
    }
}

```

removeAll 메서드로 수행



#### 집합 자료형 관련 메서드

1. add : 값 추가

   ```java
   import java.util.HashSet;
   
   public class Sample {
       public static void main(String[] args) {
           HashSet<String> set = new HashSet<>();
           set.add("Jump");
           set.add("To");
           set.add("Java");
           System.out.println(set);  // [Java, To, Jump] 출력
       }
   }
   
   ```

   

2. addAll : 여러개 한꺼번에 추가

   ```java
   import java.util.Arrays;
   import java.util.HashSet;
   
   public class Sample {
       public static void main(String[] args) {
           HashSet<String> set = new HashSet<>();
           set.add("Jump");
           set.addAll(Arrays.asList("To", "Java"));
           System.out.println(set);  // [Java, To, Jump] 출력
       }
   }
   
   ```

   

3. remove : 특정값 제거

   ```java
   import java.util.Arrays;
   import java.util.HashSet;
   
   public class Sample {
       public static void main(String[] args) {
           HashSet<String> set = new HashSet<>(Arrays.asList("Jump", "To", "Java"));
           set.remove("To");
           System.out.println(set);  // [Java, Jump] 출력
       }
   }
   
   ```

   

##### (참고) TreeSet과 LinkedHashSet

- TreeSet : 오름차순으로 값을 정렬하여 저장
- LinkedHashSet : 입력한 순서대로 값을 정렬하여 저장





### 상수집합 (Enum)

서로 관련있는 여러개의 상수 집합을 정의할 때 사용하는 자료형



#### Enum 만들기

```java
enum CoffeeType {
    AMERICANO,
    ICE_AMERICANO,
    CAFE_LATTE
};

```



#### Enum 사용

직접 출력 가능

```java
public class Sample {
    enum CoffeeType {
        AMERICANO,
        ICE_AMERICANO,
        CAFE_LATTE
    };

    public static void main(String[] args) {
        System.out.println(CoffeeType.AMERICANO);  // AMERICANO 출력
        System.out.println(CoffeeType.ICE_AMERICANO);  // ICE_AMERICANO 출력
        System.out.println(CoffeeType.CAFE_LATTE);  // CAFE_LATTE 출력
    }
}

```



혹은 반복문으로도 사용 가능

```java
public class Sample {
    enum CoffeeType {
        AMERICANO,
        ICE_AMERICANO,
        CAFE_LATTE
    };

    public static void main(String[] args) {
        for(CoffeeType type: CoffeeType.values()) {
            System.out.println(type);  // 순서대로 AMERICANO, ICE_AMERICANO, CAFE_LATTE 출력
        }
    }
}

```

`CoffeeType.values()`는 CoffeType의 배열을 리턴



#### Enum의 필요성

- 매직넘버(1과 같은 숫자 상수값)을 사용할 떄보다 코드가 명확해진다.
- 잘못된 값을 사용함으로 인해 발생할 수 있는 위험성이 사라진다.





### 형변환

String -> Integer

```java
public class Sample {
    public static void main(String[] args) {
        String num = "123";
        int n = Integer.parseInt(num);
        System.out.println(n);  // 123 출력
    }
}

```



Integer -> String

```java
public class Sample {
    public static void main(String[] args) {
        int n = 123;
        String num = "" + n; // 앞에 빈 문자열 더해주기
        System.out.println(num);  // 123 출력
    }
}
```

```java
public class Sample {
    public static void main(String[] args) {
        int n = 123;
        String num1 = String.valueOf(n);
        String num2 = Integer.toString(n);
        System.out.println(num1);  // 123 출력
        System.out.println(num2);  // 123 출력
    }
}
```



String -> double

```java
public class Sample {
    public static void main(String[] args) {
        String num = "123.456";
        double d = Double.parseDouble(num); // Float은 parseFloat
        System.out.println(d);
    }
}

```



double(float) <-> int

```java
public class Sample {
    public static void main(String[] args) {
        int n1 = 123;
        double d1 = n1;  // 정수를 실수로 바꿀때에는 캐스팅이 필요없다.
        System.out.println(d1);  // 123.0 출력

        double d2 = 123.456;
        int n2 = (int) d2; // 실수를 정수로 바꿀때에는 반드시 정수형으로 캐스팅해 주어야 한다.
        System.out.println(n2);  // 소숫점이 생략된 123 출력
    }
}

```

(참고) 실수를 정수로 변환하면 소숫점은 제거됨, 실수 형태의 문자열을 정수로 변경하려고 하면 NumberFormatException이 발생

```
public class Sample {
    public static void main(String[] args) {
        String num = "123.456";
        int n = Integer.parseInt(num);  // 실수 형태의 문자열을 정수로 변환할 경우 NumberFormatException이 발생한다.
    }
}

```

실수 형태의 문자열을 숫자형으로 변경하려면 `Double.parseDouble()` 을 사용하여 실수로 바꾼후에 사용



### final

final은 자료형에 값을 단 한번만 설정할 수 있게 강제하는 키워드

값을 한번 설정하면 그 값을 다시 설정할 수 없음

```java
public class Sample {
    public static void main(String[] args) {
        final int n = 123;  // final 로 설정하면 값을 바꿀수 없다.
        n = 456;  // 컴파일 에러 발생
    }
}

```

리스트의 경우, final로 선언시 재할당은 불가능

```java
import java.util.ArrayList;
import java.util.Arrays;

public class Sample {
    public static void main(String[] args) {
        final ArrayList<String> a = new ArrayList<>(Arrays.asList("a", "b"));
        a = new ArrayList<>(Arrays.asList("c", "d"));  // 컴파일 에러 발생
    }
}

```

따라서 final은 프로그램 수행 도중 그 값이 변경되면 안되는 상황에 사용



#### (참고) Unmodifiable List

리스트의 경우 final로 선언시 리스트에 값을 더하거나 빼는 것이 가능 (재할당이 불가능 한 것)

만약 더하기 빼기도 금지 시키고 싶다면, List.of로 수정이 불가능한 리스트로 만들기

```java
import java.util.List;

public class Sample {
    public static void main(String[] args) {
        final List<String> a = List.of("a", "b"); // Unmodifiable List 생성
        a.add("c");  // UnsupportedOperationException 발생
    }
}

```





## 제어문



### if



#### 기본 구조

```java
boolean money = true;
if (money) {
    System.out.println("택시를 타고 가라");
}else {
    System.out.println("걸어가라");
}

```

Else if 

```java
boolean hasCard = true;
ArrayList<String> pocket = new ArrayList<String>();
pocket.add("paper");
pocket.add("handphone");

if (pocket.contains("money")) {
    System.out.println("택시를 타고 가라");
}else if(hasCard) {
    System.out.println("택시를 타고 가라");
}else {         
    System.out.println("걸어가라");
}

```





#### and(&&), or(||), not(!)

```java
int money = 2000;
boolean hasCard = true;

if (money>=3000 || hasCard) {
    System.out.println("택시를 타고 가라");
} else {
    System.out.println("걸어가라");
}

```



#### contains

```java
ArrayList<String> pocket = new ArrayList<String>();
pocket.add("paper");
pocket.add("handphone");
pocket.add("money");

if (pocket.contains("money")) {
    System.out.println("택시를 타고 가라");
}else {
    System.out.println("걸어가라");
}

```





### switch/case

#### 기본구조

```java
switch(입력변수) {
    case 입력값1: ...
         break;
    case 입력값2: ...
         break;
    ...
    default: ...
         break;
}

```

Break 문이 case마다 달려있는데, 만약 break가 없다면 다음 case문이 실행됨

만약 해당되는 case가 없다면 마지막의 default문이 실행됨

switch 조건문에 들어갈 수 있는 입력 변수의 타입은 byte, short, char, int 만 가능



### while

#### 기본구조

```java
while (조건문) {
    <수행할 문장1>;
    <수행할 문장2>;
    <수행할 문장3>;
    ...
}
```

조건문이 참인 동안 문장들을 반복 수행

```java
int treeHit = 0;
while (treeHit < 10) {
    treeHit++;
    System.out.println("나무를  " + treeHit + "번 찍었습니다.");
    if (treeHit == 10) {
        System.out.println("나무 넘어갑니다.");
    }
}

```

- break를 이용해서 중단
- continue를 이용하면 반복문의 처음으로 돌아감



### for문

#### 전형적인 for문

```java
for (초기치; 조건문; 증가치) {
    ...
}

```

';' 를 구분자로 초기치, 조건문, 증가치를 이용해 반복

```java
String[] numbers = {"one", "two", "three"};
for(int i=0; i<numbers.length; i++) {
    System.out.println(numbers[i]);
}
```

마찬가지로 break와 continue 사용 가능

이중for문 등으로 응용 가능



### for each

반복 가능한 객체를 순회하면서 가능

```java
for (type var: iterate) {
    body-of-loop
}

```

```java
String[] numbers = {"one", "two", "three"};
for(String number: numbers) {
    System.out.println(number);
}

```

numbers의 요소를 하나씩 순서대로 꺼내서 number라는 변수로 반복문에서 사용





## 객체지향 프로그래밍



### 클래스

#### 기본형태

```java
class Animal {
}

public class Sample {
    public static void main(String[] args) {
    }
}

```

보통 클래스는 특별한 경우가 아니라면 파일 단위로 하나씩만 작성하고, 해당 파일의 이름과 클래스의 이름을 맞춰는 것이 일반적



#### 객체 생성

```java
class Animal {
}

public class Sample {
    public static void main(String[] args) {
        Animal cat = new Animal(); // 객체 생성
    }
}

```

`new`는 객체를 생성할 때 사용하는 키워드, 여기서는 cat 이라는 Animal의 인스턴스가 만들어진다.

(참고) 인스턴스라는 표현은 특정 객체가 어떤 클래스의 객체인지 그 관계를 설명하기 위해 사용되는 표현



#### 객체 변수 (instance variable)

```java
class Animal {
    String name; // 객체 변수
}

public class Sample {
    public static void main(String[] args) {
        Animal cat = new Animal();
    }
}

```

객체 변수는 인스턴스 변수, 멤버 변수, 속성이라고도 불림

클래스에 선언된 변수를 객체 변수라고 부름

객체 변수는 `객체.객체변수`로 접근해서 사용 가능

```java
cat.name // 객체 : cat, 객체변수 : name
```



#### 메서드

클래스 내에 선언된 함수가 메서드

자바에서는 모든 것이 클래스로 되어있기 때문에 모든 함수는 메서드로 부름

```java
class Animal {
    String name;

    public void setName(String name) {
        this.name = name; // thiss는 해당 메서드가 호출된 객체 (이 예시에서는 cat)
    }
}

public class Sample {
    public static void main(String[] args) {
        Animal cat = new Animal();
      	cat.setName("gittgi") // 메서드 호출
        System.out.println(cat.name);
    }
}

```

객체 변수는 다른 객체들끼리 공유되지 않는다

따라서 cat이 아닌 dog에서는 위에서 설정한 이름이 찍히지 않는다





### 메서드 심화

#### 기본구조

```java
public class Sample {
    int sum(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int a = 3;
        int b = 4;

        Sample sample = new Sample();
        int c = sample.sum(a, b);

        System.out.println(c);
    }
}

```



#### 매개변수와 인수

매개변수(parameter) : 메서드에 입력으로 전달된 값을 받는 변수

인수(arguments) : 메서드를 호출할 때 전달하는 입력값

```java
public class Sample {
    int sum(int a, int b) {  // a, b 는 매개변수
        return a+b;
    }

    public static void main(String[] args) {
        Sample sample = new Sample();
        int c = sample.sum(3, 4);  // 3, 4는 인수

        System.out.println(c);
    }
}

```



#### 입출력 유무에 따른 메서드 분류

1. 입력과 출력이 모두 있는 메서드

   ```java
   int sum(int a, int b) {
       return a+b;
   }
   
   ```

   return으로 주어지는 값의 자료형을 메서드 명 앞에 표기해주어야 한다.

   ```java
   Sample sample = new Sample();
   int result = sample.sum(3, 4); // 활용 할 때에도, return값을 저장할 변수에다가 할당
   
   ```

   

2. 입력값이 없는 메서드

   ```java
   public class Sample {
       String say() {
           return "Hi";
       }
   
       public static void main(String[] args) {
           Sample sample = new Sample();
           String a = sample.say();
           System.out.println(a);  // "Hi" 출력
       }
   }
   
   ```

   인수 없이 단순히 호출해서 쓸 수 있다

   

3. 리턴값이 없는 메서드

   ```
   public class Sample {
       void sum(int a, int b) { 
           System.out.println(a+"과 "+b+"의 합은 "+(a+b)+"입니다.");
       } // 리턴값이 없기 때문에, 리턴값 자료형 대신 void 표기
   
       public static void main(String[] args) {
           Sample sample = new Sample();
           sample.sum(3, 4); // 따로 return 값을 받을 변수에 할당하지 않는다
       }
   }
   
   ```

   리턴 값이 없기에 그냥 statement를 수행하는 용도로 사용



4. 입력값도 리턴값도 없는 메서드

   ```java
   public class Sample {
       void say() {
           System.out.println("Hi");
       }
   
       public static void main(String[] args) {
           Sample sample = new Sample();
           sample.say(); // 인수도 없이 그냥 호출
       }
   }
   
   ```



#### (참고) 자바파일에 2개 이상의 클래스 선언하기

하나의 파일에 여러개의 클래스를 선언하는 것은 가능함, 다만 파일명과 같은 이름을 가진 클래스는 public으로 선언하라는 관례가 있음



### Call by Value

메서드에 값(primitive type)을 전달하는 것과 객체(reference type)를 전달하는 것은 다르다

메서드에 객체를 전달할 경우, 메서드에서 객체의 객체변수 값을 변경 가능



```java
class Updater {
    void update(int count) {
        count++;
    }
}

class Counter {
    int count = 0;  // 객체변수
}

public class Sample {
    public static void main(String[] args) {
        Counter myCounter = new Counter();
        System.out.println("before update:"+myCounter.count); // 0
        Updater myUpdater = new Updater();
        myUpdater.update(myCounter.count);
        System.out.println("after update:"+myCounter.count); // 여전히 0
    }
}

```

값을 객체에서 꺼내서 전달하게 되면, 그 값은 객체와 무관하게 됨



```java
class Updater {
    void update(Counter counter) {
        counter.count++; // 받은 객체의 객체변수를 찾아서 올림
    }
}

class Counter {
    int count = 0;  // 객체변수
}

public class Sample {
    public static void main(String[] args) {
        Counter myCounter = new Counter();
        System.out.println("before update:"+myCounter.count); // 0
        Updater myUpdater = new Updater();
        myUpdater.update(myCounter);
        System.out.println("after update:"+myCounter.count); // 이제 1로 올라감
    }
}

```

객체로 전달하면, 메서드에서 그 객체의 속성을 변경가능해짐



### 상속

자식 클래스가 부모 클래스의 기능을 그대로 물려받을 수 있는 상속 기능



#### 기본구조

```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Dog extends Animal {  // Animal 클래스를 상속한다.
}

public class Sample {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.setName("poppy");
        System.out.println(dog.name);
    }
}

```

extends 키워드를 이용해서 부모 클래스를 상속 받으면, 부모 클래스의 객체 변수 및 메서드를 따로 정의 없이 그대로 사용 가능



#### 부모 클래스의 기능 확장

```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    void sleep() {
        System.out.println(this.name+" zzz"); // 부모 클래스에는 없는 자식 클래스만의 메서드
    }
}

public class Sample {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.setName("poppy");
        System.out.println(dog.name);
        dog.sleep();
    }
}

```

부모 클래스의 기능을 모두 상속 받으면서 추가로 자식 클래스만의 메서드나 변수를 설정할 수 있음



#### IS-A 관계

모든 자식 클래스 객체는 부모 클래스 객체의 자료형인 것처럼 사용 가능

```java
Animal dog = new Dog();  // Dog is a Animal
```



그러나 그 반대는 성립하지 않는다

```java
Dog dog = new Animal();  // 컴파일 오류: 부모 클래스로 만든 객체는 자식 클래스의 자료형으로 사용할 수 없다.
```



##### (참고) Object 클래스

자바의 모든 클래스는 Object 클래스를 상속받음

따라서 Object 자료형으로 사용할 수 있음





#### 메서드 오버라이딩 (Method Overriding)

```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    void sleep() {
        System.out.println(this.name + " zzz");
    }
}

class HouseDog extends Dog {
    void sleep() {
        System.out.println(this.name + " zzz in house"); // 같은 메서드이지만 더 추가 됨
    }
}

public class Sample {
    public static void main(String[] args) {
        HouseDog houseDog = new HouseDog();
        houseDog.setName("happy");
        houseDog.sleep();  // happy zzz in house 출력
    }
}

```

이처럼 부모클래스의 메서드를 자식클래스가 동일한 형태로 또 다시 덮었는 행위를 메서드 오버라이딩이라고 부름



#### 메서드 오버로딩 (Method Overloading)

메서드 오버라이딩이 변경이었다면, 메서드 오버로딩의 경우에는 추가

```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    void sleep() {
        System.out.println(this.name + " zzz");
    }
}

class HouseDog extends Dog {
    void sleep() {
        System.out.println(this.name + " zzz in house");
    }

    void sleep(int hour) {
        System.out.println(this.name + " zzz in house for " + hour + " hours");
    } // 같은 이름이지만 들어가는 입력항목이 다르다
}

public class Sample {
    public static void main(String[] args) {
        HouseDog houseDog = new HouseDog();
        houseDog.setName("happy");
        houseDog.sleep();  // happy zzz in house 출력
        houseDog.sleep(3);  // happy zzz in house for 3 hours 출력
    }
}

```

이처럼 입력항목이 다른 경우, 동일한 이름의 메서드를 만들 수 있음 -> 메서드 오버로딩



**(참고) 자바는 다중상속을 지원하지 않는다**





### 생성자

메서드명이 클래스명과 동일하고 리턴 자료형을 정의하지 않는 메서드를 생성자(Constructor)

생성자는

1. 클래스명과 메서드명이 동일해야하고
2. 리턴 타입을 정의하지 않아야 한다 (void도 쓰지 않는다)

```java
(... 생략 ...)

class HouseDog extends Dog {
    HouseDog(String name) {
        this.setName(name);
    } // 생성자

    void sleep() {
        System.out.println(this.name + " zzz in house");
    }

    void sleep(int hour) {
        System.out.println(this.name + " zzz in house for " + hour + " hours");
    }
}

(... 생략 ...)

```

이렇게 만든 생성자는 new 키워드가 사용될 때 (객체가 생성될 때) 호출됨

이때 파라미터를 설정했다면, 해당 인자를 넣어주지 않으면 컴파일 오류 발생 (예시에서는 name)

```java
(... 생략 ...)

public class Sample {
    public static void main(String[] args) {
        HouseDog dog = new HouseDog("happy"); // 객체 생성시에 이제 name을 넣어줘야 함
        System.out.println(dog.name);
    }
}

```



#### 디폴트 생성자

```
class Dog extends Animal {
    Dog() {
    }

    void sleep() {
        System.out.println(this.name + " zzz");
    }
}

```

위와 같이 생성자 내부에 아무 내용이 없는 생성자를 디폴트 생성자라고 부름

생성자를 따로 지정하지 않으면 컴파일러가 위와 같은 디폴트 생성자를 추가

만약 사용자가 작성한 생성자가 구현되어 있다면, 컴파일러는 디폴트 생성자를 추가하지 않는다

따라서 만약 `new HouseDog()`과 같이 아무 인자도 받지 않는 생성자도 같이 쓰고 싶다면 따로 디폴트 생성자를 또 만들어 줘야 함



#### 생성자 오버로딩

메서드 오버로딩 처럼, 하나의 클래스에 입력항목이 다른 생성자를 만들 수 있다

```java
class Animal {
    String name;

    void setName(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    void sleep() {
        System.out.println(this.name + " zzz");
    }
}

class HouseDog extends Dog {
    HouseDog(String name) {
        this.setName(name);
    } // 문자열을 넣은 경우

    HouseDog(int type) {
        if (type == 1) {
            this.setName("yorkshire");
        } else if (type == 2) {
            this.setName("bulldog");
        }
    } // 숫자를 넣은 경우

    void sleep() {
        System.out.println(this.name + " zzz in house");
    }

    void sleep(int hour) {
        System.out.println(this.name + " zzz in house for " + hour + " hours");
    }
}

public class Sample {
    public static void main(String[] args) {
        HouseDog happy = new HouseDog("happy");
        HouseDog yorkshire = new HouseDog(1);
        System.out.println(happy.name);  // happy 출력
        System.out.println(yorkshire.name);  // yorkshire 출력
    }
}

```





### 인터페이스

implements 키워드를 사용해서 클래스 인터페이스를 구현하도록 함

```
(... 생략 ...)

interface Predator {
}

class Tiger extends Animal implements Predator {
}

class Lion extends Animal implements Predator {    
}

(... 생략 ...)

```

이렇게 하면 각각의 클래스 대신 인터페이스를 자료형으로 쓸 수 있음

```java
/*
변경전
class ZooKeeper {
    void feed(Tiger tiger) {
        System.out.println("feed apple");
    }

    void feed(Lion lion) {
        System.out.println("feed banana");
    }
}
호랑이 객체와 사자 객체를 따로 넣어줘야함
*/

// 변경후
class ZooKeeper {
    void feed(Predator predator) {
        System.out.println("feed apple");
    }
}
// 포식자 인터페이스 객체로 통일
```

이렇게 되면 사육사 객체는 매번 새로운 동물마다 각 클래스를 받는 함수를 따로 메서드 오버로딩 할 필요 없이 프레데터 인터페이스 객체를 받는 하나의 메서드만 있으면 됨 (이후 다른 클래스들이 인터페이스를 구현하도록 하면 됨) 



#### 인터페이스의 메서드

위와 같은 경우, 모든 predetor가 같은 함수를 사용하게 되는데

이를 방지하기 위해 인터페이스안에 메서드를 정의할 수 있다

```java
interface Predator {
    String getFood();
}

(... 생략 ...)

```

이때 인터페이스 내에 정의한 메서드에는 몸통만 정의됨

인터페이스는 규칙이기 때문에, 이 규칙(인터페이스)을 따르는 클래스들은 해당 메서드를 반드시 가져야 한다는 제약을 가지게 됨

따라서 각 동물 클래스들은 각자 그 메서드를 구현해야할 의무가 있음

```java
(... 생략 ...)

class Tiger extends Animal implements Predator {
    public String getFood() {
        return "apple";
    } // 인터페이스의 메서드는 항상 public으로 구현해야 함
}

class Lion extends Animal implements Predator {
    public String getFood() {
        return "banana";
    }
}

(... 생략 ...)

```

이후 해당 인터페이스 객체를 받는 메서드에서 이렇게 활용 가능

```java
(... 생략 ...)

class ZooKeeper {
    void feed(Predator predator) {
        System.out.println("feed "+predator.getFood());
    } // 이렇게 호출하면, 구현체가 각자 정의한 getFood() 메서드가 호출됨
}

(... 생략 ...)

```



#### 인터페이스가 필요한 이유

위의 예시에서 볼 수 있듯이, 매번 동물의 종류를 추가할 때마다 추가와 동시에 사육사 클래스를 수정해야하는 문제를 해결할 수 있다

사육사 클래스는 인터페이스 객체를 받는 것으로 대신하는 것으로, 다른 종류의 클래스가 추가가 되더라도 따로 사육사 클래스를 수정할 필요없는, 독립적인 클래스가 될 수 있다.

물론 Animal 클래스에 getFood메서드를 추가하고 이를 오버라이딩 하는 것으로 대체는 가능하지만, 상속의 경우에는 자식 클래스가 부모클래스의 메서드를 오버라이딩 하지 않고 그대로 사용하는 방법이 가능하다. 반대로 인터페이스의 경우에는 **인터페이스의 메서드를 반드시 구현해야 하는 강제성**이 있다.



#### 디폴트 메서드

인터페이스는 메서드 몸통을 가질 수 없지만, 디폴트 메서드를 사용하면 실제 구현된 형태의 메서드를 가질 수 있다.

```java
interface Predator {
    String getFood();

    default void printFood() {
        System.out.printf("my food is %s\n", getFood());
    } // 디폴트 메서드
}

```

이렇게 디폴트 메서드를 정의하면 이 인터페이스의 구현체에서는 따로 해당 메서드를 구현하지 않아도 사용할 수 있다

동시에 오버라이딩 해서 따로 구현하는 것도 가능하다



#### 스태틱 메서드

인터페이스에 스태틱메서드를 선언하면 `인터페이스명.스테틱메서드명` 처럼, 일반 클래스의 스태틱 메서드를 사용하는 것과 동일하게 사용할 수 있다.

```java
interface Predator {
    String getFood();

    default void printFood() {
        System.out.printf("my food is %s\n", getFood());
    }

    int LEG_COUNT = 4;  // 인터페이스 상수, public static final이 자동 적용됨, 다른 형태의 상수 정의 X

    static int speed() {
        return LEG_COUNT * 30;
    } // Predetor.speed(); 로 사용가능
}

```



#### 인터페이스 다중 상속

```java
interface Predator {
    (... 생략 ...)
}

interface Barkable {
    void bark();
}

interface BarkablePredator extends Predator, Barkable {
} // 인터페이스는 다중 상속이 가능하다

(... 생략 ...)

```

인터페이스는 클래스와 다르게 다중 상속을 지원





### 추상클래스

추상클래스는 인터페이스의 역할도 하면서 클래스의 기능도 가지고 있는 돌연변이 클래스

보통 추상클래스를 인터페이스로 대체하는 것이 좋은 디자인이라고 함



```java
abstract class Predator extends Animal { // 추상 클래스
    abstract String getFood(); // 인터페이스 메서드와 동일

    /*default*/ void printFood() {  // default 를 제거한다.
        System.out.printf("my food is %s\n", getFood());
    }

    static int LEG_COUNT = 4;  // 추상 클래스의 상수는 static 선언이 필요하다.
    static int speed() {
        return LEG_COUNT * 30;
    }
}

(... 생략 ...)

```

추상클래스를 만들기 위해서는 class 앞에 abstract 키워드 사용

또한 인터페이스 메서드와 같은 역할을 하는 메서드에도 abstract 키워드 사용, 몸통이 없고 이를 상속받는 클래스에서 해당 abstract 메서드를 구현해야함

디폴트 메서드는 사용할 수 없고, 상수 역시 인터페이스에서는 자동으로 static으로 인식하지만 추상 클래스에서는 따로 선언해줘야 함

추상 클래스는 일반 클래스와 달리 단독으로 객체를 생성할 수 없고 반드시 해당 추상클래스를 상속한 실제 클래스를 통해서만 객체 생성 가능

추상클래스에는 abstract 메서 외에 실제 메서드도 사용 가능, 이 경우 이를 상속받은 객체들도 그 메서드를 사용가능 (인터페이스의 default 메서드와 동일)



#### 인터페이스와 추상 클래스의 차이

자바 8 버전 부터 인터페이스에 default 메서드가 추가되어 추상 클래스와의 차이점이 모호해짐

하지만 추상 클래스는 인터페이스와는 달리 일반 클래스처럼 객체변수, 생성자, private 메서드등을 가질 수 있다





## 입출력



### 콘솔 입출력



#### 콘솔 입력

사용자가 입력한 문자열을 얻기 위해서는 `System.in` 사용

```java
import java.io.IOException;
import java.io.InputStream;

public class Sample {
    public static void main(String[] args) throws IOException {
        InputStream in = System.in; // 입력

        int a;
        a = in.read(); // 여기서 입력대기

        System.out.println(a); // 'a'를 입력한 경우 97(아스키 코드) 출력
    }
}

```

`InputStream` (`java.io` 임포트 필요) 객체로 입력값 저장

InputStream의 read 메서드는 1byte의 사용자 입력을 받음

그러나 byte 자료형이 아닌 int 자료형으로 저장됨(0!255 사이의 정수값 -> 아스키 코드 값)

(참고) `throws IOException` : InputStream으로부터 값을 읽어들일 때는 IOException이 발생할 수 있어서 예외처리가 필요, throws는 그 예외처리를 뒤로 미루게 한 것



만약 1글자(1byte) 3글자(3bye)를 받고 싶다면

1. 3번 실행

   ```java
   import java.io.IOException;
   import java.io.InputStream;
   
   public class Sample {
       public static void main(String[] args) throws IOException {
           InputStream in = System.in; // abc(입력 + 엔터)
   
           int a;
           int b;
           int c;
   
           a = in.read(); // read 3번 실행
           b = in.read();
           c = in.read();
   
           System.out.println(a); // 97
           System.out.println(b); // 98
           System.out.println(c); // 99
       }
   }
   
   ```

2. byte 배열로 만들어서 전달

   ```java
   import java.io.IOException;
   import java.io.InputStream;
   
   public class Sample {
       public static void main(String[] args) throws IOException {
           InputStream in = System.in;
   
           byte[] a = new byte[3]; // 길이 3짜리 바이트 배열
           in.read(a); // read 메서드에 배열 전달
   
           System.out.println(a[0]);
           System.out.println(a[1]);
           System.out.println(a[2]);
       }
   }
   
   ```



#### InputStreamReader

입력 값을 아스키코드가 아니라 문자값 그대로 보는 방법

```java
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader; // 추가 import

public class Sample {
    public static void main(String[] args) throws IOException {
        InputStream in = System.in;
        InputStreamReader reader = new InputStreamReader(in); //InputStream 객체 전달
        char[] a = new char[3]; // 이제 Char 배열 사용 가능
        reader.read(a); // InputStreamReader에도 read 메서드

        System.out.println(a); // abc
    }
}

```

InputStreamReader에 InputStream 객체 전달



#### BufferedReader

고정된 길이가 아니라, 사용자가 엔터키를 입력할 때까지 사용자의 입력을 전부 받아들이는 방법

```java
import java.io.IOException;
import java.io.BufferedReader; // 새 import
import java.io.InputStream;
import java.io.InputStreamReader;

public class Sample {
    public static void main(String[] args) throws IOException {
        InputStream in = System.in;
        InputStreamReader reader = new InputStreamReader(in);
        BufferedReader br = new BufferedReader(reader); // InputStreamReader 객체 전달

        String a = br.readLine(); // readLine 메서드를 이용해서 문자열 전부 읽기
        System.out.println(a);
    }
}

```



정리하면 

- InputStream - byte
- InputStreamReader - character
- BufferedReader - String



#### Scanner

```java
import java.util.Scanner; // import 필요

public class Sample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in); // 콘솔입력(System.in) 객체 전달
        System.out.println(sc.next()); // next는 단어 하나(Token)을 읽어들임
    }
}

```

Scanner 클래스에는 단어, 라인, 정수 등 다양하게 읽어들일 수 있는 메서드들이 준비 되어 있음

- next - 단어
- nextLine - 라인
- nextInt - 정수



#### 콘솔 출력

- `System.out` : PrintStream의 객체로 출력에 많이 쓰임

- `System.err` : 역할은 동일하지만 에러메세지 출력에 쓰임

  - Unix의 경우 콘솔 프로그램 실행 시 출력 옵션을 지정하면 System.out으로 출력한 내용과 System.err로 출력한 내용을 별도의 파일로 저장할 수 있음

    ``` java
    public class Sample {
        public static void main(String[] args) {
            System.out.println("일반 출력"); // out.txt에 생성
            System.err.println("에러 출력"); // error.txt에 생성
        }
    }
    
    ```



### 파일 입출력



#### 파일 쓰기

```java
import java.io.FileOutputStream; // import
import java.io.IOException;

public class Sample {
    public static void main(String[] args) throws IOException {
        FileOutputStream output = new FileOutputStream("c:/out.txt"); // 경로 입력
        output.close(); // 사용한 파일은 닫아주기 (프로그램이 종료될 때 자동으로 닫히기는 함)
    }
}

```



#### FileOutputStream

```java
import java.io.FileOutputStream;
import java.io.IOException;

public class Sample {
    public static void main(String[] args) throws IOException {
        FileOutputStream output = new FileOutputStream("c:/out.txt");
        for(int i=1; i<11; i++) {
            String data = i+" 번째 줄입니다.\r\n"; // 윈도우즈에서는 \r 추가해야함
            output.write(data.getBytes()); // 파일에 쓸 때는 바이트 배열로 써야함
        }
        output.close();
    }
}

```

바이트 단위로 데이터를 처리하는 OutputStream 을 사용



#### FileWriter

바이트 대신 문자열로 사용할 수 있는 객체

```java
import java.io.FileWriter;
import java.io.IOException;

public class Sample {
    public static void main(String[] args) throws IOException {
        FileWriter fw = new FileWriter("c:/out.txt");
        for(int i=1; i<11; i++) {
            String data = i+" 번째 줄입니다.\r\n";
            fw.write(data);
        }
        fw.close();
    }
}

```



#### PrintWiter

`\r\n` 을 쓰지 않고 `println` 메서드를 이용 가능하게끔 하는 객체

```java
import java.io.IOException;
import java.io.PrintWriter;

public class Sample {
    public static void main(String[] args) throws IOException {
        PrintWriter pw = new PrintWriter("c:/out.txt");
        for(int i=1; i<11; i++) {
            String data = i+" 번째 줄입니다.";
            pw.println(data); // System.out과 같음, 다만 콘솔 대신 파일에 저장할 뿐
        }
        pw.close();
    }
}

```



#### 파일에 내용 추가

`FileWriter`에 두번째 파라미터를 true로 하면 추가 가능

이 경우 기존 내용을 덮어쓰지 않고 이후부터 파일이 쓰여짐

```java
import java.io.FileWriter;
import java.io.IOException;

public class Sample {
    public static void main(String[] args) throws IOException {
        FileWriter fw = new FileWriter("c:/out.txt");
        for(int i=1; i<11; i++) {
            String data = i+" 번째 줄입니다.\r\n";
            fw.write(data);
        }
        fw.close();

        FileWriter fw2 = new FileWriter("c:/out.txt", true);  // 파일을 추가 모드로 연다.
        for(int i=11; i<21; i++) {
            String data = i+" 번째 줄입니다.\r\n";
            fw2.write(data);
        }
        fw2.close();
    }
}

```



PrintWriter 객체를 활용 할 때에는 추가모드로 열린 FileWriter를 전달하면 된다

```java
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class Sample {
    public static void main(String[] args) throws IOException {
        PrintWriter pw = new PrintWriter("c:/out.txt");
        for(int i=1; i<11; i++) {
            String data = i+" 번째 줄입니다.";
            pw.println(data);
        }
        pw.close();


        PrintWriter pw2 = new PrintWriter(new FileWriter("c:/out.txt", true)); // 여기
        for(int i=11; i<21; i++) {
            String data = i+" 번째 줄입니다.";
            pw2.println(data);
        }
        pw2.close();
    }
}

```



#### 파일 읽기

FileInputStream 이용하는 방법

```java
import java.io.FileInputStream;
import java.io.IOException;

public class Sample {
    public static void main(String[] args) throws IOException {
        byte[] b = new byte[1024];
        FileInputStream input = new FileInputStream("c:/out.txt");
        input.read(b);
        System.out.println(new String(b));  // byte 배열을 문자열로 변경하여 출력
        input.close();
    }
}

```

다만 문제는 byte단위로 읽어야 하기 때문에 정확한 길이를 모를 경우에는 불편



따라서 라인 단위로 읽을 수 있는 BufferedReader 사용

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Sample {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new FileReader("c:/out.txt")); // 여기
        while(true) {
            String line = br.readLine(); // readLine의 메서드는 더이상 읽을 라인이 없을 경우 null 리턴
            if (line==null) break;  // 더 이상 읽을 라인이 없을 경우 while 문을 빠져나간다.
            System.out.println(line);
        }
        br.close();
    }
}

```





## 자바 심화



### 패키지

패키지는 비슷한 성격의 자바 클래스를 모아 놓은 자바의 디렉토리



#### 패키지

```java
// house/HouseKim.java
package house; // 패키지명 표시

public class HouseKim {
}

```

```java
// house/HousePark.java
package house; // 패키지명 표시

public class HousePark {
}

```



#### 서브패키지

패키지 하위에 서브패키지 생성 가능

```java
// house/person/EungYongPark.java
package house.person; // . 으로 하위패키지 구분

public class EungYongPark {
}

```



#### 패키지 사용하기

어떤 클래스를 다른 클래스를 사용하려면 import

```java
import house.HouseKim;

public class Sample {
    public static void main(String[] args) {
        HouseKim kim = new HouseKim();
    }
}

```

혹은 * 기호를 이용하면 패키지 내의 모든 클래스를 사용할 수 있다

```java
import house.*;

public class Sample {
    public static void main(String[] args) {
        HouseKim kim = new HouseKim();
        HousePark park = new HousePark();
    }
}

```



만약 동일한 패키지 내에 있는 클래스라면 따로 import를 필요로 하지 않는다.

```java
package house;

public class HousePark {
    public static void main(String[] args) {
        HouseKim kim = new HouseKim();  // HouseKim 사용을 위해서 import가 필요없다.
    }
}

```



#### 패키지를 사용하는 이유

- 클래스의 분류를 용이하게 함
- 패키지가 다르다면 동일한 클래스명을 사용할 수 있다





### 접근제어자

접근 제어자의 종류로는 4가지

- private
- default
- protected
- public

`private -> default -> protected -> public` 순으로 보다 많은 접근을 허용



#### private

private 는 해당 클래스에서만 접근 가능

``` java
public class Sample {
    private String secret;
    private String getSecret() {
        return this.secret;
    }
}

```



#### default

접근제어자를 별도로 설정하지 않는다면 default 접근제어자가 됨

해당 패키지 내에서만 접근이 가능

```java
package house;  // 패키지가 동일하다.

public class HousePark {
    String lastname = "park";

    public static void main(String[] args) {
        HouseKim kim = new HouseKim();
        System.out.println(kim.lastname);  // HouseKim 클래스의 lastname 변수를 사용할 수 있다.
    }
}

```



#### protected

protected는 동일 패키지의 클래스, 해당 클래스를 상속받은 다른 패키지의 클래스에서만 접근 가능

```java
package house.person;  // 패키지가 서로 다르다.

import house.HousePark;

public class EungYongPark extends HousePark {  // HousePark을 상속했다.
    public static void main(String[] args) {
        EungYongPark eyp = new EungYongPark();
        System.out.println(eyp.lastname);  // 상속한 클래스의 protected 변수는 접근이 가능하다.
    }
}

```

패키지가 서로 다르지만 protected 변수가 속한 클래스와 같은 패키지에 속해 있는 HousePark 클래스를 상속했기 때문에 사용 가능



#### public

어떤 클래스에서라도 접근이 가능

```java
package house;

public class HousePark {
    protected String lastname = "park";
    public String info = "this is public message.";
}

```





### 스태틱



#### static 변수

static 키워드를 붙이면 자바는 메모리 할당을 딱 한번만 하게 됨

메모리적 이점 + 같은 메모리 주소만을 바라보기 때문에 공유 개념으로도 활용 가능 

```java
class HouseLee {
    static String lastname = "이"; // 매번 객체를 만들 때마다 새로 변수를 주는 것이 아니라 딱 한번만 변수 선언
}

public class Sample {
    public static void main(String[] args) {
        HouseLee lee1 = new HouseLee();
        HouseLee lee2 = new HouseLee();
    }
}

```

```java
class Counter  {
    static int count = 0; // 카운터가 여러개이더라도 하나의 카운트를 같이 센다
    Counter() {
        count++;  // count는 더이상 객체변수가 아니므로 this를 제거하는 것이 좋다.
        System.out.println(count);  // this 제거
    }
}

public class Sample {
    public static void main(String[] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();
    }
}

```



#### static 메서드

스태틱 메서드 안에서는 객체변수 접근이 불가능, 스태틱 변수 접근은 가능

보통 "오늘의 날짜 구하기", "숫자에 콤마 추가하기" 등의 유틸리티성 메서드를 작성할 때 많이 사용

```java
class Counter  {
    static int count = 0;
    Counter() {
        count++;
        System.out.println(count);
    }

    public static int getCount() {
        return count;
    }
}

public class Sample {
    public static void main(String[] args) {
        Counter c1 = new Counter();
        Counter c2 = new Counter();

        System.out.println(Counter.getCount());  // 스태틱 메서드는 클래스를 이용하여 호출
    }
}

```

```java
import java.text.SimpleDateFormat;
import java.util.Date;

class Util {
    public static String getCurrentDate(String fmt) {
        SimpleDateFormat sdf = new SimpleDateFormat(fmt);
        return sdf.format(new Date());
    }
}

public class Sample {
    public static void main(String[] args) {
        System.out.println(Util.getCurrentDate("yyyyMMdd"));  // 오늘 날짜 출력
    }
}

```



#### 싱글톤 패턴

```java
class Singleton {
    private static Singleton one; // 싱글톤 객체
    private Singleton() { 
    } // private이기 때문에 여기서만 생성가능

    public static Singleton getInstance() {
        if(one==null) {
            one = new Singleton(); // 싱글톤 객체가 없을 때만 생성하도록
        }
        return one;
    }
}

public class Sample {
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        System.out.println(singleton1 == singleton2);  // true 출력
    }
}
// 다만 이 방식은 스레드 세이프하지 않다
```





### 예외처리

`FileNotFoundException` : 존재 하지 않는 파일을 열려고 시도

`ArithmeticException` : 0으로 나누는 등의 시도

`ArrayIndexOutofBoundsException` : 배열의 길이를 넘어가는 접근



#### 예외 처리하기

**try - catch**

```java
try {
    ...
} catch(예외1) {
    ...
} catch(예외2) {
    ...
}

```

try 문에서 예외가 발생하지 않는다면 catch문이 발동하지 않는다

예외가 발생하면 예외에 따라서 catch 문 발동

```java
int c;
try {
    c = 4 / 0;
} catch(ArithmeticException e) {
    c = -1;  // 예외가 발생하여 이 문장이 수행된다.
}

```



**finally**

예외 발생 및 catch 문이 발생하더라도 반드시 실행해야 하는 부분을 적는 곳

```java
public class Sample {
    public void shouldBeRun() {
        System.out.println("ok thanks.");
    }

    public static void main(String[] args) {
        Sample sample = new Sample();
        int c;
        try {
            c = 4 / 0;
        } catch (ArithmeticException e) {
            c = -1;
        } finally {
            sample.shouldBeRun();  // 예외에 상관없이 무조건 수행된다.
        }
    }
}

```



**RuntimeException / Exception**

- RuntimeException : 실행시 발생하는 예외 -> 발생 할 수도, 안 할수도 있는 경우 작성
- Exception : 컴파일시 발생하는 예외 -> 이미 예측가능한 예외를 작성할 때 사용



**RuntimeException**

```java
class FoolException extends RuntimeException {
} // RuntimeException 클래스를 상속받은 FooleException 클래스 및 객체 생성

public class Sample {
    public void sayNick(String nick) {
        if("fool".equals(nick)) {
            throw new FoolException(); // 단순 return으로 종료시키는 것이 아니라 적극적으로 예외 발생시키기 
        }
        System.out.println("당신의 별명은 "+nick+" 입니다.");
    }

    public static void main(String[] args) {
        Sample sample = new Sample();
        sample.sayNick("fool");
        sample.sayNick("genious");
    }
}


```

```java
Exception in thread "main" FoolException
    at Sample.sayNick(Sample.java:7)
    at Sample.main(Sample.java:14)
// 다음과 같은 예외 발생
```



**Exception**

위와 같은 방식으로 바꾸면, 컴파일 시점에서 오류가 발생

예측 가능한 에러이기 때문에 예외처리를 해주어야 컴파일러가 컴파일 해줌

따라서 try - catch 구문으로 에러처리 필요

```java
class FoolException extends Exception {
}

public class Sample {
    public void sayNick(String nick) {
        try {
            if("fool".equals(nick)) {
                throw new FoolException();
            }
            System.out.println("당신의 별명은 "+nick+" 입니다.");
        }catch(FoolException e) {
            System.err.println("FoolException이 발생했습니다."); // FoolException 예외 처리
        }
    }

    public static void main(String[] args) {
        Sample sample = new Sample();
        sample.sayNick("fool");
        sample.sayNick("genious");
    }
}

```



#### 예외 던지기 (throws)

throws를 사용하면 예외가 발생한 메서드가 아니라 그 메서드의 상위 메서드에서 발생하도록 할 수 있음

```java
class FoolException extends Exception {
}

public class Sample {
  // 예외 처리를 sayNick이 아니라 이 메서드를 불러오는 그 상위 메서드에서 발생하게끔
    public void sayNick(String nick) throws FoolException { 
        if("fool".equals(nick)) {
            throw new FoolException();
        }
        System.out.println("당신의 별명은 "+nick+" 입니다.");
    }

    public static void main(String[] args) {
        Sample sample = new Sample();
        try {
            sample.sayNick("fool");
            sample.sayNick("genious");
        } catch (FoolException e) {
            System.err.println("FoolException이 발생했습니다."); // 예외처리를 이제 여기서 해주어야 함
        }
    }
}

```



**예외 처리 시점**

위 예시에서, sayNick 메서드에서 예외를 처리하는 경우에는 다음 두 문장이 모두 수행

```java
sample.sayNick("fool"); // 예외 발생
sample.sayNick("genious"); // 그대로 수행

```

그러나 main 메서드에서 예외 처리를 하는 경우, 그 즉시 catch 문으로 빠지기 때문에 두번째 문장이 실행되지 않는다

```java
try {
    sample.sayNick("fool");
    sample.sayNick("genious");  // 이 문장은 수행되지 않는다.
}catch(FoolException e) {
    System.err.println("FoolException이 발생했습니다.");
}

```

이 점을 고려해서 예외처리 시점 선택



### Thread

쓰레드를 이용하면 한 프로세스 내에서 두 가지 또는 그 이상의 일을 동시에 처리할 수 있다.



#### Thread

```java
public class Sample extends Thread {
    public void run() {  // Thread 를 상속하면 run 메서드를 구현해야 한다.
        System.out.println("thread run.");
    }

    public static void main(String[] args) {
        Sample sample = new Sample();
        sample.start();  // start()로 쓰레드를 실행한다.
    }
}

```

Thread 클래스의 경우 start 메서드 실행시 run 메서드가 수행됨



```java
public class Sample extends Thread {
    int seq;

    public Sample(int seq) {
        this.seq = seq;
    }

    public void run() {
        System.out.println(this.seq + " thread start.");  // 쓰레드 시작
        try {
            Thread.sleep(1000);  // 1초 대기한다.
        } catch (Exception e) {
        }
        System.out.println(this.seq + " thread end.");  // 쓰레드 종료 
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {  // 총 10개의 쓰레드를 생성하여 실행한다.
            Thread t = new Sample(i);
            t.start();
        }
        System.out.println("main end.");  // main 메서드 종료
    }
}

/*
0 thread start.
4 thread start.
6 thread start.
2 thread start.
main end.
3 thread start.
7 thread start.
8 thread start.
1 thread start.
9 thread start.
5 thread start.
0 thread end.
4 thread end.
2 thread end.
6 thread end.
7 thread end.
3 thread end.
8 thread end.
9 thread end.
1 thread end.
5 thread end.
*/
```

쓰레드는 순서와 상관없이 동시에 수행됨

추가로 쓰레드가 종료되기 전에 main 메서드가 종료됨



#### join

```java
import java.util.ArrayList;

public class Sample extends Thread {
    int seq;
    public Sample(int seq) {
        this.seq = seq;
    }

    public void run() {
        System.out.println(this.seq+" thread start.");
        try {
            Thread.sleep(1000);
        }catch(Exception e) {
        }
        System.out.println(this.seq+" thread end.");
    }

    public static void main(String[] args) {
        ArrayList<Thread> threads = new ArrayList<>(); // 스레드를 담을 배열
        for(int i=0; i<10; i++) {
            Thread t = new Sample(i);
            t.start();
            threads.add(t); // 배열에 스레드 넣기
        }

        for(int i=0; i<threads.size(); i++) {
            Thread t = threads.get(i);
            try {
                t.join(); // t 쓰레드가 종료할 때까지 기다린다.
            }catch(Exception e) {
            }
        }
        System.out.println("main end.");
    }
}

/*
0 thread start.
5 thread start.
2 thread start.
6 thread start.
9 thread start.
1 thread start.
7 thread start.
3 thread start.
8 thread start.
4 thread start.
0 thread end.
5 thread end.
2 thread end.
9 thread end.
6 thread end.
1 thread end.
7 thread end.
4 thread end.
8 thread end.
3 thread end.
main end.
*/
```

각 쓰레드가 종료될 때 까지 기다리게 한다음 (join) 다 종료되면 main 메서드가 종료되도록 할 수 있다

쓰레드가 종료된 후 그 다음 로직 수행해야 하는 경우 join 메서드 사용



#### Runnable

쓰레드 객체를 만들때 Thread 클래스를 상속하기도 하지만 이 경우 다른 클래스를 상속하기 어려움

따라서 Runnable 인터페이스를 구현하도록 하는 방법을 주로 사용

```java
import java.util.ArrayList;

public class Sample implements Runnable {
    int seq;
    public Sample(int seq) {
        this.seq = seq;
    }

    public void run() {
        System.out.println(this.seq+" thread start.");
        try {
            Thread.sleep(1000);
        }catch(Exception e) {
        }
        System.out.println(this.seq+" thread end.");
    } // Runnable 인터페이스는 run 메서드를 구현하도록 강제

    public static void main(String[] args) {
        ArrayList<Thread> threads = new ArrayList<>();
        for(int i=0; i<10; i++) {
            Thread t = new Thread(new Sample(i)); // 쓰레드 생성시 Runnable 객체를 넘길 수 있다
            t.start();
            threads.add(t);
        }

        for(int i=0; i<threads.size(); i++) {
            Thread t = threads.get(i);
            try {
                t.join();
            }catch(Exception e) {
            }
        }
        System.out.println("main end.");
    }
}

```

Runnable 인터페이스는 run 메서드를 구현하도록 강제

쓰레드 생성시 Runnable 객체를 넘길 수 있다

이 경우 인터페이스를 이용했디 때문에 상속 등에서 좀 더 유연한 프로그래밍이 가능



### 함수형 프로그래밍



#### 람다(Lambda)

```java
interface Calculator {
    int sum(int a, int b);
}

class MyCalculator implements Calculator {
    public int sum(int a, int b) {
        return a+b;
    }
} // calculator 인터페이스를 사용하기 위해 클래스 생성

public class Sample {
    public static void main(String[] args) {
        MyCalculator mc = new MyCalculator();
        int result = mc.sum(3, 4); 
        System.out.println(result);  // 7 출력
    }
}

```

람다를 사용하면 다음과 같이 구현 가능

```java
interface Calculator {
    int sum(int a, int b);
}

public class Sample {
    public static void main(String[] args) {
        Calculator mc = (int a, int b) -> a +b; // 실제 클래스 없이도 calculator 사용 가능
        int result = mc.sum(3, 4);
        System.out.println(result);
    }
}

```



#### 인터페이스 사용시 주의사항

인터페이스의 메서드가 1개 이상이면 람다 함수를 사용할 수 없음 (컴파일 에러 발생)

따라서 람다함수로 사용할 인터페이스가 있다면 `@FunctionalInterface` 어노테이션을 사용

이렇게 하면 해당 인터페이스는 2개 이상의 메서드를 가지는 것이 불가능

```java
@FunctionalInterface
interface Calculator {
    int sum(int a, int b);
    int mul(int a, int b);  // @FunctionalInterface 는 두 번째 메서드를 허용하지 않는다.
}

```



#### 람다 축약

```java
(int a, int b) -> a + b

```

```java
interface Calculator {
    int sum(int a, int b);
}

public class Sample {
    public static void main(String[] args) {
        Calculator mc = (a, b) -> a +b;
        int result = mc.sum(3, 4);
        System.out.println(result);
    }
}

```

**(참고) Integer.sum**

`(a, b) -> a + b` 는 `Integer.sum(int a, int b)`와 동일하기 때문에 더 축약이 가능

```java
Integer::sum

```

`::` 의 경우 클래스와 메서드를 구분할때 사용하는 표기

```java
@FunctionalInterface
interface Calculator {
    int sum(int a, int b);
}

public class Sample {
    public static void main(String[] args) {
        Calculator mc = Integer::sum;
        int result = mc.sum(3, 4);
        System.out.println(result);
    }
}

```



#### 람다 함수 인터페이스

인터페이스 생성 대힌 함수형 프로그래밍을 위해 제공되는 인터페이스를 사용 가능

```java
import java.util.function.BiFunction; // import

@FunctionalInterface
interface Calculator {  // BiFunction 인터페이스를 사용하면 Calculator 인터페이스가 필요없다.
    int sum(int a, int b);
}

public class Sample {
    public static void main(String[] args) {
        BiFunction<Integer, Integer, Integer> mc = (a, b) -> a + b;
        int result = mc.apply(3, 4);  // sum이 아닌 apply 메서드를 사용해야 한다.
        System.out.println(result);  // 7 출력
    }
}

```

`<Integer, Integer, Integer>` 제네릭스는 순서대로 입력항목 2개, 출력항목 1개를 의미

여기에 BiFunction의 apply 메서드를 호출하면 람다함수가 실행됨



또한 입출력 항목이 위처럼 동일한 경우, `BinaryOperator` 를 사용하여 더 간단하게 표현 가능

```java
import java.util.function.BinaryOperator;

public class Sample {
    public static void main(String[] args) {
        BinaryOperator<Integer> mc = (a, b) -> a + b;
        int result = mc.apply(3, 4);
        System.out.println(result);  // 7 출력
    }
}

```



#### 스트림 (Stream)

콜렉션 데이터를 물결처럼 흘러가면서 필터링 및 과정들을 거쳐 변환시키는데에 사용되는 클래스

가령 배열에서 짝수만 뽑아 중복을 제거 후 역순으로 정렬하는 프로그램이라면

```java
import java.util.*;

public class Sample {
    public static void main(String[] args) {
        int[] data = {5, 6, 4, 2, 3, 1, 1, 2, 2, 4, 8};

        // 짝수만 포함하는 ArrayList 생성
        ArrayList<Integer> dataList = new ArrayList<>();
        for(int i=0; i<data.length; i++) {
            if(data[i] % 2 == 0) {
                dataList.add(data[i]);
            }
        }

        // Set을 사용하여 중복을 제거
        HashSet<Integer> dataSet = new HashSet<>(dataList);

        // Set을 다시 List로 변경
        ArrayList<Integer> distinctList = new ArrayList<>(dataSet);

        // 역순으로 정렬
        distinctList.sort(Comparator.reverseOrder());

        // Integer 리스트를 정수 배열로 변환
        int[] result = new int[distinctList.size()];
        for(int i=0; i< distinctList.size(); i++) {
            result[i] = distinctList.get(i);
        }
    }
}

```

와 같이 복잡한 과정을 거쳐야하지만, 스트림을 이용하면

```java
import java.util.Arrays;
import java.util.Comparator;

public class Sample {
    public static void main(String[] args) {
        int[] data = {5, 6, 4, 2, 3, 1, 1, 2, 2, 4, 8};
        int[] result = Arrays.stream(data)  // IntStream을 생성한다.
                .boxed()  // IntStream을 Stream<Integer>로 변경한다.
                .filter((a) -> a % 2 == 0)  //  짝수만 뽑아낸다.
                .distinct()  // 중복을 제거한다.
                .sorted(Comparator.reverseOrder())  // 역순으로 정렬한다.
                .mapToInt(Integer::intValue)  // Stream<Integer>를 IntStream으로 변경한다.
                .toArray()  // int[] 배열로 반환한다.
                ;
    }
}

```

좀더 간결하고 가독성있는 코딩이 가능
