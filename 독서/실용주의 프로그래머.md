# 실용주의 프로그래머

데이비드 토머스 - 앤드류 헌트 지음

정지용 옮김 | 김창준 감수



100가지 팁

1. **자신의 기예(craft)에 관심을 가져라.**

   - 실용주의 프로그래머들의 특징
     - 얼리 어댑터 또는 새로운 것에 빨리 적응하는 사람
     - 호기심 많은 사람
     - 비판적인 사고의 소유자
     - 현실주의자
     - 다방면에 능숙한 사람
     - 그리고 자신의 기예(craft)에 관심을 가지는 사람 - 개발 능력을 발전시키는데에 관심을 갖는 사람

2. **자기 일에 대해 생각하라.**

   - 어떤 일을 하면서 자기가 무엇을 하고 있는 지 생각할 것, 모든 개발 과정에서 내리는 모든 결정을 끊임없이 비판적으로 평가할 것

3. **당신에게는 에이전시(agency)가 있다.**

   - agency : 주체적으로 원하는 행동을 고르고 행할 수 있는 능력
   - 업무 환경이 엉망이서나 하는 일이 지루하다면 문제를 고치기 위해 노력할 것, 그것이 불가능 하다면 다른 곳을 찾을 것
   - "당신은 당신의 조직을 바꾸거나, 당신의 조직을 바꿀 수 있다" - 마틴 파울러

4. **어설픈 변명 말고 대안을 제시하라.**

   - 변명 대신 상황을 개선하기 위해 무엇을 할 수 있는지 설명할 것
   - 추가적인 소요나 필요한 도움이 있다면 부탁을 어려워 하지 말고 필요하다는 사실을 인정할 것
   - 책임지고 해결하려는 자세가 전문성과 신뢰를 만든다

5. **깨진 창문을 내버려 두지 말아라.**

   - 소프트웨어 엔트로피, 소프트웨어 부패, 기술 부채
   - 나쁜 설계, 잘못된 결정, 혹은 형편없는 코드 등의 방치는 코드의 부패를 가속화 -> 발견 즉시 고칠 것
   - 적절히 고칠 시간이 없다면 일단 판자로 덮자 (주석 처리, 미구현 메세지 표시, 더미 데이터 대치), 어떤 조치든 취하고, 상황이 관리되고 있음을 보여줄 것
   - 베스트는 우선 망가트리지 않는 것, 깨진 창문은 없어야 한다

6. **변화의 촉매가 되어라.**

   - 돌멩이 수프 이야기
   - 일에 착수하기 위해 허락을 구하는 때부터, 모든 사람이 각자 자신의 자원을 지키려고 할 것 - ''시작 피로''
   - 큰 무리 없이 요구할 수 있을 만한 것을 찾아서 잘 개발할 것, 그리고 그것을 보여주면서 사람들이 경탄하게 할 것
   - 이후 애초에 원했던 기능을 추가해 달라고 사람들이 부탁하기 시작할 때까지 기다릴 것
   - 미래를 살짝이라도 보여준다면, 사람들은 도와주기 위해 모여든다. "계속되는 성공에 합류하기란 쉽다"

7. **큰 그림을 기억하라.**

   - 삶은 개구리 / 돌멩이 수프에서의 마을 사람들
   - 너무 작아서 알아채기 힘들 정도의 문제를 시작으로 서서히 프로젝트가 변질 됨
   - 혹은 지엽적인 부분에만 집중한 나머지, 전체 프로젝트가 변질되고 있다는 사실을 눈치채지 못함
   - 언제나 큰 그림을 인지하고, 주변에서 무슨 일이 벌어지는지 살펴볼 것

8. **품질을 요구 사항으로 만들어라.**

   - 품질 타협 과정에 사용자를 참여시킬 것
   - 만드는 시스템의 범위와 품질은 해당 시스템의 요구 사항 중 하나로 논의되어야 함
   - 지나칠 정도로 장식하고나 다듬느라 망치지 말고 코드를 현재 상태로 한동아 놓아 둘 것, 그만 둘 때를 알 것

9. **지식 포트폴리오에 주기적으로 투자하라.**

   - 지식 포트폴리오는 투자 포트폴리오와 유사
     - 주기적인 투자 : 방해를 받지 않을 수 있는 시간과 정소를 정기적으로 이용할 계획을 마련 할 것
     - 다각화 : 빠르게 변화하는 컴퓨터 지형에 맞춰 다양한 분야 + 기술외 역량에 대해 적응 할 것
     - 리스크 관리 : 보상과 리스크의 편차가 다양한 기술들에 골고루 투자할 것
     - 싸게 사서 비싸게 팔기 : 신 기술이 인기를 끌기 전에 미리 알고 학습하는 것은 어렵지만 큰 이득을 가져옴
     - 검토 및 재조정 : 인기 기술의 인기가 떨어지거나, 한동안 사용하지 않았던 기술이 재조명 받을 수 있다
   - 제안하는 지식 포트폴리오 목표
     - 매년 새로운 언어를 최소 하나는 배울 것 : 새 언어는 사고를 확장
     - 기술 서적을 한 달에 한 권씩 읽을 것
     - 기술 서적이 아닌 책도 읽을 것 : 컴퓨터도 사람이 사용하는 것이고, 우리는 이 사람들을 만족시키기 위해 노력중임을 명심
     - 수업을 들을 것
     - 지역 사용자 단체나 모임에 참여할 것
     - 다른 환경에서 실험해 볼 것 : 윈도우파면 리눅스에서, IDE파면 텍스트 에디터에서 개발해 볼 것
     - 요즘 흐름을 놓치지 말것 : 뉴스와 온라인 게시물을 통해 다른 사람들이 어떤 경험을 하고 있는지 체크

10. **읽고 듣는 것을 비판적으로 분석하라.**

    - 기술 포트폴리오를 쌓기 위해 접하게 되는 여러 자료(책, 웹 페이지, 컨텐츠 등)에 대해 받아드리기 전에 비판적으로 분석하기
      - 왜 냐고 다섯 번 묻기
      - 누구에게 이익이 되는지 따져보기
      - 어떤 맥락인지 보기 : 예) 최고의 방법 -> "누구에게 최고인가?, 전제조건은?, 장기적 단기적 여파는?"
      - 언제 혹은 어디서 효과가 있을까? : 다음에 어떤 일이 일어날까? 에서 멈추지 말고 그 다음 단계까지
      - 왜 이것이 문제인가?

11. **한국어든 영어든 하나의 프로그래밍 언어일 뿐이다.**

    - 사람을 위한 글을 쓰는 것도 코드를 쓰는 것과 같다. DRY, ETC, 자동화를 지켜가며 쓰자
    - 소통을 하기 위해서는
      - 청중을 알고
      - 말하고 싶은게 무엇인지 알고
      - 때를 알고
      - 스타일을 고르고
      - 멋져 보이게 할 것
      - 그리고 청중을 참여시키고
      - 경청할 것
      - 응답할 것
      - 마지막으로 의사소통을 문서화해서 코드를 포함시킬 것

12. **무엇을 말하는가의 어떻게 말하는가 모두 중요하다.**

13. **문서를 애초부터 포함하고, 나중에 집어넣으려고 하지말라.**

    - 모듈과 외부로 노출하는 함수에 주석을 달것
    - API가 아닌 코드에 주석을 쓸 때에는 왜 이렇게 되어 있는지, 즉 코드의 용도와 목적을 쓸 것, 어떻게 동작하는지는 이미 코드가 나타내고 있다
    - 소스코드에 다는 주석은 프로젝트에서 쉽게 누락되는 부분을 문서화할 수 있는 기회, 예를 들면 기술적인 절충점이나 결정의 이유, 폐기한 다른 대안 등

14. **좋은 설계는 나쁜 설계보다 바꾸기 쉽다.**

    - 모든 좋은 설계의 핵심 : ETC(Easier To Change)
    - 세상의 모든 설계 원칙은 ETC의 특수 케이스
      - 결합도를 줄이면 좋은 이유? : 관심사를 분리하는 것으로, 각각을 더 바꾸기 쉽게
      - 왜 단일 책임 원칙이 유용한가? : 요구 사항이 바뀌더라도 모듈 하나만 바꿔서 반영할 수 있기 때문
      - 왜 이름 짓기가 중요한가? : 코드가 읽기 쉬워지고, 코드를 바꾸려면 코드를 읽어야 하기 때문 등 
    - ETC는 규칙이 아니라 가치
      - 스스로에게 자꾸 물어볼 것 : "내가 방금 한 일이 전체 시스템을 바꾸기 쉽게 만들었을까?"
      - 앞으로 어떤 모습으로 바뀔지 잘 모르겠을 때는, 언제건 궁극의 '바꾸기 쉽게' 라는 길을 선택
        - 교체가 가능하다면 이 코드가 앞길을 막는 일은 없을 것
        - 교체 가능하게 작성하라는 말은 코드의 결합도를 낮추고 응집도를 높이라는 뜻
      - 또한 이런 선택과 변경사항에 대해, 당시 했던 추측을 소스코드에 남겨 둘 것
        - 이후 이 코드를 바꿔야 하는 시점에 피드백이 되어 줄 것 + 다음에 나타날 같은 종류의 갈림길에서 도움을 줄 것

15. **DRY : 반복하지 말라.**

    - 소프트웨어를 신뢰성 높게 개발하는 유일한 길, 개발을 이해하고 유지보수하기 쉽게 만드는 유일한 길 -> DRY 원칙
    - 모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다
    - 하나를 바꾸면 나머지도 바꿔야 하는 악몽을 막기
    - DRY는 코드 밖에서도 적용 되어야 함
      - 단순히 코드 복사 붙여넣기에만 해당하는 것이 아님
      - 지식의 중복, 의도의 중복, 똑같은 개념을 다른 두 곳에 표현하면 안된다는 뜻
        - 표현 방식이 다르더라도 같은 개념을 표현한 것이면 중복
        - 반대로 같은 표현이더라도 표현하고자 하는 개념 혹은 지식이 다른 것이면 중복이 아님
      - 주석 역시 코드로 충분히 설명이 되는 것을 주석으로 다는 것은 중복
      - 데이터 역시 중복의 대상
        - 가령 시작점과 끝점 변수가 있으면, 따로 길이 변수를 두는 것은 중복, 계산 필드로 만드는 것이 낫다
        - 다만 성능상의 이유로 원칙을 위배할 수 있다. -> 이 경우 중복의 영향을 국소화하기 위해 클래스 내에서 메서드가 고생하는 것으로, 바깥 세상에는 원칙 위배를 노출 하지 않는 방향성
      - (참고) 모듈이 자료구조를 노출하면, 언제나 모듈의 구현과 그 자료구조를 사용하는 코드 사이에 결합 발생
        - 따라서 가능하다면 언제나 객체의 속성을 읽고 쓸 때 접근자(accessor) 함수를 사용할 것
    - 작성한 코드가 다른 라이브러리나 다른 서비스등과 연결될 때에는, 다른 서비스의 API나 스키마, 에러코드등의 의미를 내 코드가 알아야 하기 때문에 필연적으로 중복이 발생 (해당 스키마가 바뀌면 내 코드도 바꿔줘야 하는 불편)
      - 이를 완화하기 위한 방법
        - 내부 API에서 생기는 중복의 경우에는 내부 API를 정의할 수 있는 도구를 이용하여 정의하고 이를 중앙저장소에서 관리하면서 여러팀이 공유할 수 있도록 할 것
        - 외부 API에서 생기는 경우 OpenAPI와 같이 문서화된 API명세를 활용해서 관리
    - 데이터 저장소와의 중복 역시 고려 대상
      - 데이터 저장소에서 제공하는 스키마 분석기능 활용 -> 직접 데이터 객체를 옮기는 코드를 만들기 보다는 스키마로부터 바로 생성 될 수 있도록 (혹은 영속성 프레임워크인 하이버네이트, 마이바티스 등 활용)
      - 다만 이 방식은 필요한 만큼만 데이터에 접근하는 것으로 생기는 안전장치가 많이 사라진다. 따라서 이 방식을 사용할 땐 데이터를 한 겹 더 감쌀 것(간단한 표 기반의 검증도구 계층 등)
    - 개발자 간의 중복
      - 똑같은 일을 하는 코드가 우연히 중복으로 추가 될 가능성
      - 최선은 개발자간의 적극적이고 빈번한 소통
        - 일일 스크럼 미팅, 슬랙 채널 활용
        - 프로젝트 사서 임명 : 역할은 지식의 교환
        - 유틸리티 루틴과 스크립트를 모아둘 수 있는 장소 마련
        - 빈번한 상호 코드리뷰

16. **재사용하기 쉽게 만들어라.**

    - 뭔가를 직접 만드는 것보다 기존의 것을 찾아내고 재사용하기 쉬운 환경을 조성할 것
    - 재사용을 통해서 지식 중복의 가능성을 낮출 수 있다

17. **관련 없는 것들 간에 서로 영향이 없도록 하라.**

    - 직교적인 시스템의 두 가지 큰 장점
      - 생산성 향상
        - 컴포넌트 단위로 설계, 작성, 테스트 하고 다음으로 넘어가는 것이 가능, 새 코드를 추가할 때마다 다른 코드를 수정하지 않아도 됨
        - 명확하고 잘 정의된 컴포넌트라면 다른 컴포넌트와 함께 사용되는 등의 재사용 및 재조합, 개량이 쉬워짐
        - 직교적인 컴포넌트 두 개를 결합하는 경우에는 M * N개의 기능적 구현 가능성이 생긴다
      - 리스크 감소
        - 감염된 코드가 격리될 가능성이 높다. 문제 부분만 도려내고 새 코드를 이식하기 쉽다
        - 시스템이 잘 깨지지 않는다. 문제가 생겼을 때, 그 작은 부분만 깨질 것
        - 작은 컴포넌트들을 설계하고 실행하는 것이 쉽기 때문에, 테스트 역시 더 많이 하게 될 것
        - 특정 업체나 제품, 플랫폼에 종속되는 것을 줄일 수 있다. 외부 컴포넌트로 연결되는 인터페이스들을 전체 개발의 작은 부분안에 격리시키기 때문
    - 직교성을 표현하는 방식 : 모듈식, 컴포넌트 기반, 계층
      - 시스템은 서로 협력하는 모듈의 집합, 각 모듈은 다른 부분과 독립적인 기능을 구현
      - 계층 구조에서 각 계층은 자기 바로 밑에 있는 계층이 제공하는 추상화만을 사용하기 때문에, 다른 코드에 영향을 끼치지 않으면서 기반 구현들을 변경 가능
    - 설계가 직교적인지 확인하는 방법
      - 컴포넌트들을 나누었을 때, 특정 기능에 대한 요구 사항을 대폭 변경시에 단 한 개의 모듈만 영향을 받는가?
      - 또한 현실 세계의 변화와 설계 사이의 결합도도 체크
        - 고객 식별자가 전화번호인 경우, 전화번호 체계가 바뀌기라도 한다면..
    - 툴킷이나 라이브러리 도입시에도 시스템에 수용해서는 안될 변화를 강요하는지, 직교성을 해치지 않는지 체크
    - 코딩 시에 직교성을 유지할 수 있는 방법 들
      - 코드의 결합도를 줄일 것
        - 불필요한 것은 다른 모듈에 보여주지 않고, 다른 모듈의 구현에 의존하지 않는 shy한 코드르 작성
      - 전역 데이터를 피할 것
        - 전역 데이터는 이를 사용하는 모든 코드와 묶이게 하는 주범
        - 읽기 전용으로 쓴다 할지라도 멀티스레드 환경에서는 문제 가능성
        - 싱글턴도 같은 문제
        - 따라서 필요한 컨텍스트를 명시적으로 넘겨주는 방식(매개변수, 컨텍스트를 포함하는 구조체를 만들어 참조로 넘기기) 사용
      - 유사한 함수 피하기
        - 시작과 끝이 동일하지만 중간의 알고리즘이 다른 경우
        - 전략 패턴을 사용하여 더 낫게 구현할 수는 없는지 고민
    - 직교적인 시스템은 테스트하기 더 쉽다
      - 통합 테스트 보다 단위 테스트가 더 쉽다
      - 에러의 여파가 국지적인지를 통해 직교성을 평가 가능
    - 직교성은 문서에도 적용할 수 있다
      - 내용과 표현을 직교적으로 분리
      - 어떤 내용이라도 갈아낄 수 있도록

18. **최종 결정이란 없다.**

    - 결정이 바뀌지 않을 것이라 가정하고서 발생할지도 모를 우연한 사건에 대비하지 않는 데에서 실수가 나온다
    - 소프트웨어의 개발 속도는 요구 사항, 사용자, 하드웨어의 변화를 앞지를 수 없기 때문에 유연한 대처가 필요할 것이다
    - 코드 뿐만 아니라 아키텍처, 배포, 외부 제품과의 통합 영역에서도 유연할 필요가 있다

19. **유행을 좇지 말라**

    - 아키텍처의 관점에서도 유행은 계속해서 바뀐다(심지어는 거대한 쇳덩이로 복고하는 경우도)
    - 따라서 우리가 할 수 있는 일은 코드를 여러 컴포넌트로 쪼개고, 외부의 API를 우리가 만든 추상화 계층으로 숨기는 등, 바꾸기 쉽게 만드는 것(ETC)
    - 미래는 알 수 없으니 유연한 대처가 가능하게 만들어라

20. **목표물을 찾기 위해 예광탄을 써라**

    - 전형적인 개발은, 시스템을 극도로 세세히 명세화 하는 것, 상당한 양의 계산을 통해서 최종 목표의 위치를 추측하고 한번의 발사로 맞추기를 바란다
    - 그러나 실용주의 프로그래머는 소프트웨어 판 예광탄을 선호
      - 시스템을 정의하는 중요한 요구 사항, 의문이 드는 부분이나 가장 위험이 커 보이는 곳을 찾고, 이런 부분의 코드를 가장 먼저 작성하도록 개발 우선순위를 정하기
      - 예광탄 코드의 시작은 프로젝트를 만들고, "hello world!"를 추가한 다음, 컴파일 및 실행 시키는 것
      - 이후 전체 어플리케이션에서 불확실한 곳이 어디인지 찾아보고 해당 부분을 작동시키는데 필요한 뼈대를 추가하는 것
      - 사용자 인터페이스부터 권한 부여, 비지니스 로직, 데이터 모델, 데이터 베이스에 이르기까지 각 계층의 가장 기본적인 부분을 관통, 통합하는 기본 구조를 만드는 것을 시작
      - 이후 기본 구조가 작동을 하면, 각 계층에 살을 붙여 나가면서 정교화 하는 것
      - 예광탄 코드는 한번 쓰고 버리는 코드가 아닌, 아직 모든 기능이 완료 되지 않은 조준선
      - "프로젝트는 결코 끝나지 않는다"의 견해에 맞춰, 지속적인 변경 요청 및 기능 추가 요청에 점진적으로 대응 가능
    - 예광탄 코드의 장점
      - 사용자가 뭔가 작동하는 것을 일찍 보게 된다
        - 자신이 쓸 시스템에 진전이 있음을 확인하는 것으로, 진행 사항에 대해 알려 줄 수 있고, 관심을 높일 수 있고, 피드백 등의 기여도도 높일 수 있다
      - 개발자가 들어가서 일할 수 있는 구조를 얻는다
        - 애플리케이션의 모든 요소 간 상호 작용을 다 만들고 코드로 구체화까지 해놓았다면, 개발자들은 이제 각 파트에 살을 붙이기만 하면 된다.
      - 통합(Integration) 작업을 수행할 기반이 생긴다
        - 한번의 모든 것을 통합하는 것이 아니라, 각 단위 별로 매일 붙여 볼 수 있는 기반이 생긴다.
        - 새로 도입된 변화가 통합된 후에 어떤 영향을 주는지 빠르게 확인하고 디버깅 할 수 있다.
      - 보여줄 것이 생긴다
        - 프로젝트 후원자 및 고위층은 가장 껄끄러운 시간에 데모를 보고 싶어한다.
        - 예광탄 코드를 도입하면, 언제나 보여줄 코드를 가지고 있는 셈
      - 진행 상황에 대해 더 정확하게 감을 잡을 수 있다
        - 예광탄 코드를 토대로 작은 단위들을 붙여나가기 때문에, 수행을 평가하기 쉽고, 얼마나 진전되었는지 보여주기 쉽다
        - "95%" 완성에서 진척이 없는 거대한 코드 덩어리가 생기는 것을 피할 수 있다
    - 예광탄 코드라고 해서 언제나 목표물을 맞추는 것은 아님
      - 그러나 가벼운 개발 방법론이기 때문에 코드를 변경하면서 목표물에 맞게끔 쉽게 옮길 수 있다
      - 특히 애플리케이션의 모든 주요 요소가 예광탄 코드에도 들어있기 때문에, 명세가 아니라 현실에 기반을 두고 있다는 확신도 얻을 수 있다
    - 예광탄 코드와 프로토타입은 다른 개념
      - 결정적인 차이는 프로토타입은 나중에 버리는 코드를 만들고, 예광탄 코드는 기능은 별로 없지만 완결된 코드이며, 최종 시스템 골격의 일부가 된다
      - 프로토타입은 예광탄을 발사하기 전에 먼저 수행하는 정찰이나 정보 수집의 역할

21. **프로토타이핑으로 학습하기**

    - 위험 요소를 분석하고 노출 시킨 후, 이를 매우 저렴한 비용으로 바로 잡을 기회를 얻는 것
      - 당장에는 중요하지 않은 세부 사항은 일단 무시하고, 알고 싶은 부분에만 집중 해서 작성
      - 꼭 코드가 아닌 포스트 잇이나 화이트 보드 등에 작업 흐름, 로직 등 다른 재료를 이용해 작성하는 것도 가능
    - 프로토타이핑 대상
      - 위험을 수반하는 모든 것 : 이전에 해본 적 없는 것, 최종 시스템에 매우 중요한 것, 증명되니 않았거나, 실험적이거나, 의심이 가는 것, 마음이 편하지 않은 것
        - 아키텍처
        - 기존 시스템에 추가할 새로운 기능
        - 외부 데이터의 구조 혹은 내용
        - 외부에서 가져온 도구나 컴포넌트
        - 성능 문제
        - 사용자 인터페이스 설계
    - 이러한 프로토타이핑은 생산한 코드나 결과물에 있는 것이 아니라 이를 통해 배우는 교훈에 있다
    - 프로토타입을 어떻게 사용할 것인가?
      - 무시해도 되는 사항
        - 정확성 : 더미를 사용해도 좋다
        - 완전성 : 제한된 방식으로만 작동해도 된다
        - 안정성 : 오류 검사를 무시해도 좋다
        - 스타일 : 프로토타입 자체의 주석이나 문서는 많지 않아야 한다. 다만 프로토타입을 사용해 본 결과를 문서로 많이 작셩할 것
      - 세부사항을 생략하고, 시스템의 특정 측면에 초점으 맞출 것
      - 실제 프로젝트에서 실제로 사용하는 언어보다 추상화 수준이 높은 언어, 가령 파이썬이나 루비 같은 고수준의 스크립트 언어가 더 수월할 수 있다
    - 아키텍처 프로토타이핑
      - 역시 세부사항은 무시하고 전체적으로 시스템이 어떻게 동작할지에 대해 감을 잡는 것
      - 코드 대신 화이트보드, 포스트잇, 인덱스 카드등을 사용할 수 있다.
      - 아키텍처 프로토타이핑에서 규명할 사안
        - 주요 영역의 책임이 잘 정의되었고 적절한가?
        - 주요 컨포넌트 간의 협력 관계가 잘 정의되었는가?
        - 결합도는 최소화했는가?
        - 중복이 발생할 만한 곳이 있는가?
        - 정의된 인터페이스와 제약사항은 수용할 만한가?
        - *각 모듈이 실행 중에 필요한 데이터에 접근할 수 있는 경로를 갖고 있는가? 모듈에 데이터가 필요한 시점에 데이터 접근이 가능한가?*
    - 프로토타입을 코드로 만든 경우에는, 이 프로토타입의 코드는 폐기 처분 될 것임을 분명히 할 것. 만약 사용해야 할 것 같으면 차라리 애초에 예광탄 코드로 접근하라

22. **문제 도메인에 가깝게 프로그래밍 하라** (보완 필요)

    - 도메인의 어휘를 사용해서 코드를 작성하는 것을 넘어서 그 도메인의 실제 어휘와 문법, 의미론을 사용해서 프로그래밍 할 것

    - 프로그래밍 언어의 사고방식보다 도메인의 언어가 해결 방안을 제안 할 수도 있다

    - 내부 도메인 언어와 외부 도메인 언어

      - RSpec이나 피닉스 라우터 등은 이들을 구현하는 호스트 언어인 루비와 엘릭서로 원하는 내용을 쓴다
        - 결과적으로 우리가 실행시키는 코드 안으로 들어옴
        - 도메인 언어가 원래 코드의 어휘를 진짜로 확장시킨다
        - 이런 경우를 내부 도메인 언어
      - 큐컴버 테스트나 앤서블 명세는 그들 자체의 언어를 사용, 코드 혹은 데이터 구조를 변환 후 실행
        - 별도의 코드가 이 언어를 읽어 들여서 사용할 수 있는 형태로 바꾸는 방식
        - 이런 경우를 외부 도메인 언어

      - 내부 도메인 언어의 장단점
        - 장점 : 호스트 언어의 기능을 사용할 수 있다 -> 우리가 만드는 도메인 언어를 더 강력하게 만들 수 있다
        - 단점 : 호스트 언어의 문법과 의미론을 따라야 한다
        - 외부 도메인 언어의 경우에는 이러한 제약이 없지만 파서를 만드는데 많은 노력이 필요할 수도 있다
      - 따라서 기본적으로는 YAML이나 Json, CSV처럼 널리 통용되는 외부 언어를 사용하거나 아니면 내부언어를 사용할 것을 권장
      - 단, 외부 언어 도입은 애플리케이션의 사용자가 직접 도메인 언어로 코드를 작성하는 경우에만 추천

23. **추정으로 놀람을 피하라**

    - 어떤 의미에서 모든 답은 추정치이다
    - 따라서 추정치가 사용될 상황에 따라 달라질 수 있다. 높은 정확도를 요구하는지, 아니면 큰 그림만을 요구하는지
    - 추정치의 단위에 따라서 해석이 달라질 수 있다 (일, 주, 달)
    - 추정치를 얻는 가장 좋은 방법은 비슷한 상황을 겪었던 사람에게 묻는 것
    - 추정하는 방법
      - 먼저 무엇을 묻고 있는지 이해할 것 : 질문에 명시적으로 드러나지 않아도 존재하는 조건을 생각하는 습관 (~한 경우가 아니라면)
      - 시스템의 모델을 만들어라
        - 기본적인 것만 갖춘 개략적인 모델을 기반으로 추정
        - 정확도는 낮을 수 있지만 표면에 드러나지 않았던 숨겨진 패턴이나 프로세스를 발견할 수 있다
        - 이를 통해 추정치 요구 질문을 재검토 하게 할 수도 있다
      - 모델을 컴포넌트로 나눠라
        - 각 컴포넌트가 전체 모델에 얼마나 어떻게 기여하는지에 대한 매개변수를 찾아서 추정할 것
        - 이때 각 매개변수를 계산할 때는 직접 측정해보거나, 비슷한 다른 시스템을 참고하는 등의 근거를 통해 값을 할당하고 계산할 것
      - 추정 실력을 기록할 것
        - 추정을 끝내면, 이를 기록해서 실제 결과와 얼마나 비슷했는지 확인할 것, 그리고 차이가 크다면 어디서 그런 차이가 났는지 평가하 것
        - 이를 통해 추정실력을 개선할 수 있을 것

24. 코드와 함께 일정도 반복하여 조정하라

25. 지식을 일반 텍스트로 저장하라

26. 명령어 셸의 힘을 사용하라

27. 에디터를 유창하게 쓸 수 있게 하라

28. 언제나 버전 관리 시스템을 사용하라

29. 비난 대신 문제를 해결하라

30. 당황하지 말라

31. 코드를 고치기 전 실패하는 테스트부터

32. 그놈의 오류 메세지 좀 읽어라

33. "select"는 망가지지 않았다

34. 가정하지 말라. 증명하라

35. 텍스트 처리 언어를 익혀라

36. 여러분은 완벽한 소프트웨어를 만들 수 없다

37. 계약으로 설계하라

38. 일찍 작동을 멈춰라

39. 단정문으로 불가능한 상황을 예방하라

40. 자신이 시작한 것은 자신이 끝내라

41. 지역적으로 행동하라

42. 작은 단계들을 밟아라. 언제나

43. 예언하지 말라

44. 결합도가 낮은 코드가 바꾸기 쉽다

45. 문지 말고 말하라 (Tell, Don't Ask)

46. 메서드 호출을 엮지 말라

47. 전역 데이터를 피하라

48. 전역적이어야 할 만큼 중요하다면 API로 감싸라

49. 프로그래밍은 코드에 관한 것이지만, 프로그램은 데이터에 관한 것이다

50. 상태를 쌓아 놓지 말고 전달하라

51. 상속세를 내지 말라

52. 다형성은 인터페이스로 표현하는 것이 좋다

53. 서비스에 위임하라. Has-A가 Is-A보다 낫다

54. 믹스인으로 기능을 공유하라

55. 외부 설정으로 애플리케이션을 조정할 수 있게 하라

56. 작업 흐름 분석으로 동시성을 개선하라

57. 공유 상태는 틀린 상태다

58. 불규칙한 실패는 동시성 문제인 경우가 많다

59. 공유 상태 없는 동시성을 위하여 액터를 사용하라

60. 칠판으로 작업 흐름을 조율하라

61. 여러분 내면의 파충류에게 귀 기울여라

62. 우연에 맡기는 프로그래밍을 하지 말라

63. 사용하는 알고리즘의 차수를 추정하라

64. 여러분의 추정을 테스트하라

65. 일찍 리팩터링하고, 자주 리팩터링하라

66. 테스트는 버그를 찾기 위한 것이 아니다

67. 테스트가 코드의 첫 번째 사용자다

68. 상향식이나 하향식이 아니라 끝에서 끝까지(end to end) 만들어라

69. 테스트할 수 있도록 설계하라

70. 여러분의 소프트웨어를 테스트하라. 그러지 않으면 사용자가 테스트하게 된다

71. 속성 기반 테스트로 가정을 검증하라 

72. 단순함을 유지하고 공격 표면을 최소화하라

73. 보안 패치를 신속히 적용하라

74. 이름을 잘 지어라. 필요하면 이름을 바꿔라

75. 자신이 뭘 원하는지 정확히 아는 사람은 아무도 없다

76. 프로그래머는 사람들이 자신이 원하는 바를 깨닫도록 돕는다

77. 요구 사항은 피드백을 반복하여 알게 된다

78. 사용자처럼 생각하기 위해 사용자와 함께 일하라

79. 정책은 메타데이터다

80. 프로젝트 용어 사전을 사용하라

81. 생각의 틀을 벗어나지 말고, 틀을 찾아라

82. 코드에 혼자 들어가지 말라

83. 애자일은 명사가 아니다. 애자일은 무언가를 하는 방식이다

84. 작고 안정적인 팀을 유지하라

85. 실현하려면 계획하라

86. 모든 기능을 갖춘 팀을 조직하라

87. 유행하는 것이 아니라 실제로 잘 맞는 것을 사용하라

88. 사용자에게 필요할 때 제공하라

89. 버전 관리 시스템으로 빌드, 테스트, 릴리스를 운용하라

90. 일찍 테스트하고, 자주 테스트하라. 자동으로 테스트하라

91. 모든 테스트가 끝날 때까지는 코딩이 끝난게 아니다

92. 버그를 심어 놓고 테스트를 테스트하라

93. 코드 커버리지만 올리지 말고 상태 조합을 테스트하라

94. 버그는 한 번만 잡아라

95. 수작업 절차를 사용하지 말라

96. 사용자를 기쁘게 하라. 그저 코드만 내놓지 말라

97. 자신의 작품에 서명하라

98. 먼저, 해를 끼치지 말라

99. 쓰레기 같은 인간을 돕지 말라

100. 결국 당신의 삶이다. 삶을 사람들과 나누고, 삶을 축하하고, 삶을 만들어가라. 그리고 그걸 즐겨라!